#![doc = "Peripheral access API for AM64X microcontrollers (generated using svd2rust v0.33.3 (bdfba32 2023-03-30))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.3/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 0] = [];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Interrupt {}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        match self {}
    }
}
#[doc = "PSRAMECC0_RAM"]
pub struct Psramecc0Ram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Psramecc0Ram {}
impl Psramecc0Ram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const psramecc0_ram::RegisterBlock = 0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const psramecc0_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Psramecc0Ram {
    type Target = psramecc0_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Psramecc0Ram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Psramecc0Ram").finish()
    }
}
#[doc = "PSRAMECC0_RAM"]
pub mod psramecc0_ram;
#[doc = "PADCFG_CTRL0_CFG0"]
pub struct PadcfgCtrl0Cfg0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PadcfgCtrl0Cfg0 {}
impl PadcfgCtrl0Cfg0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const padcfg_ctrl0_cfg0::RegisterBlock = 0x000f_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const padcfg_ctrl0_cfg0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PadcfgCtrl0Cfg0 {
    type Target = padcfg_ctrl0_cfg0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PadcfgCtrl0Cfg0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PadcfgCtrl0Cfg0").finish()
    }
}
#[doc = "PADCFG_CTRL0_CFG0"]
pub mod padcfg_ctrl0_cfg0;
#[doc = "CBASS_DBG0_ERR"]
pub struct CbassDbg0Err {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CbassDbg0Err {}
impl CbassDbg0Err {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass_dbg0_err::RegisterBlock = 0x0020_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass_dbg0_err::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CbassDbg0Err {
    type Target = cbass_dbg0_err::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CbassDbg0Err {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CbassDbg0Err").finish()
    }
}
#[doc = "CBASS_DBG0_ERR"]
pub mod cbass_dbg0_err;
#[doc = "CBASS_INFRA1_ERR"]
pub struct CbassInfra1Err {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CbassInfra1Err {}
impl CbassInfra1Err {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass_infra1_err::RegisterBlock = 0x0021_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass_infra1_err::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CbassInfra1Err {
    type Target = cbass_infra1_err::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CbassInfra1Err {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CbassInfra1Err").finish()
    }
}
#[doc = "CBASS_INFRA1_ERR"]
pub mod cbass_infra1_err;
#[doc = "CBASS_FW0_ERR"]
pub struct CbassFw0Err {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CbassFw0Err {}
impl CbassFw0Err {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass_fw0_err::RegisterBlock = 0x0022_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass_fw0_err::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CbassFw0Err {
    type Target = cbass_fw0_err::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CbassFw0Err {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CbassFw0Err").finish()
    }
}
#[doc = "CBASS_FW0_ERR"]
pub mod cbass_fw0_err;
#[doc = "PSC0"]
pub struct Psc0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Psc0 {}
impl Psc0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const psc0::RegisterBlock = 0x0040_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const psc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Psc0 {
    type Target = psc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Psc0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Psc0").finish()
    }
}
#[doc = "PSC0"]
pub mod psc0;
#[doc = "ESM0_CFG"]
pub struct Esm0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Esm0Cfg {}
impl Esm0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const esm0_cfg::RegisterBlock = 0x0042_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const esm0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Esm0Cfg {
    type Target = esm0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Esm0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Esm0Cfg").finish()
    }
}
#[doc = "ESM0_CFG"]
pub mod esm0_cfg;
#[doc = "GPIO0"]
pub struct Gpio0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio0 {}
impl Gpio0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x0060_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio0 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio0").finish()
    }
}
#[doc = "GPIO0"]
pub mod gpio0;
#[doc = "GPIO1"]
pub struct Gpio1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio1 {}
impl Gpio1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio1::RegisterBlock = 0x0060_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio1 {
    type Target = gpio1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio1").finish()
    }
}
#[doc = "GPIO1"]
pub mod gpio1;
#[doc = "PLL0_CFG"]
pub struct Pll0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pll0Cfg {}
impl Pll0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pll0_cfg::RegisterBlock = 0x0068_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pll0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pll0Cfg {
    type Target = pll0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pll0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pll0Cfg").finish()
    }
}
#[doc = "PLL0_CFG"]
pub mod pll0_cfg;
#[doc = "PSRAMECC0_ECC_AGGR"]
pub struct Psramecc0EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Psramecc0EccAggr {}
impl Psramecc0EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const psramecc0_ecc_aggr::RegisterBlock = 0x0070_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const psramecc0_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Psramecc0EccAggr {
    type Target = psramecc0_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Psramecc0EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Psramecc0EccAggr").finish()
    }
}
#[doc = "PSRAMECC0_ECC_AGGR"]
pub mod psramecc0_ecc_aggr;
#[doc = "ECC_AGGR1_ECC_AGGR"]
pub struct EccAggr1EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EccAggr1EccAggr {}
impl EccAggr1EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecc_aggr1_ecc_aggr::RegisterBlock = 0x0070_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecc_aggr1_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EccAggr1EccAggr {
    type Target = ecc_aggr1_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EccAggr1EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EccAggr1EccAggr").finish()
    }
}
#[doc = "ECC_AGGR1_ECC_AGGR"]
pub mod ecc_aggr1_ecc_aggr;
#[doc = "CPSW0_ECC"]
pub struct Cpsw0Ecc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cpsw0Ecc {}
impl Cpsw0Ecc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpsw0_ecc::RegisterBlock = 0x0070_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpsw0_ecc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cpsw0Ecc {
    type Target = cpsw0_ecc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cpsw0Ecc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cpsw0Ecc").finish()
    }
}
#[doc = "CPSW0_ECC"]
pub mod cpsw0_ecc;
#[doc = "MMCSD0_ECC_AGGR_RXMEM"]
pub struct Mmcsd0EccAggrRxmem {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmcsd0EccAggrRxmem {}
impl Mmcsd0EccAggrRxmem {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmcsd0_ecc_aggr_rxmem::RegisterBlock = 0x0070_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmcsd0_ecc_aggr_rxmem::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmcsd0EccAggrRxmem {
    type Target = mmcsd0_ecc_aggr_rxmem::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmcsd0EccAggrRxmem {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmcsd0EccAggrRxmem").finish()
    }
}
#[doc = "MMCSD0_ECC_AGGR_RXMEM"]
pub mod mmcsd0_ecc_aggr_rxmem;
#[doc = "MMCSD0_ECC_AGGR_TXMEM"]
pub struct Mmcsd0EccAggrTxmem {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmcsd0EccAggrTxmem {}
impl Mmcsd0EccAggrTxmem {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmcsd0_ecc_aggr_txmem::RegisterBlock = 0x0070_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmcsd0_ecc_aggr_txmem::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmcsd0EccAggrTxmem {
    type Target = mmcsd0_ecc_aggr_txmem::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmcsd0EccAggrTxmem {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmcsd0EccAggrTxmem").finish()
    }
}
#[doc = "MMCSD0_ECC_AGGR_TXMEM"]
pub mod mmcsd0_ecc_aggr_txmem;
#[doc = "MMCSD1_ECC_AGGR_RXMEM"]
pub struct Mmcsd1EccAggrRxmem {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmcsd1EccAggrRxmem {}
impl Mmcsd1EccAggrRxmem {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmcsd1_ecc_aggr_rxmem::RegisterBlock = 0x0070_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmcsd1_ecc_aggr_rxmem::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmcsd1EccAggrRxmem {
    type Target = mmcsd1_ecc_aggr_rxmem::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmcsd1EccAggrRxmem {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmcsd1EccAggrRxmem").finish()
    }
}
#[doc = "MMCSD1_ECC_AGGR_RXMEM"]
pub mod mmcsd1_ecc_aggr_rxmem;
#[doc = "MMCSD1_ECC_AGGR_TXMEM"]
pub struct Mmcsd1EccAggrTxmem {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmcsd1EccAggrTxmem {}
impl Mmcsd1EccAggrTxmem {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmcsd1_ecc_aggr_txmem::RegisterBlock = 0x0070_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmcsd1_ecc_aggr_txmem::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmcsd1EccAggrTxmem {
    type Target = mmcsd1_ecc_aggr_txmem::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmcsd1EccAggrTxmem {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmcsd1EccAggrTxmem").finish()
    }
}
#[doc = "MMCSD1_ECC_AGGR_TXMEM"]
pub mod mmcsd1_ecc_aggr_txmem;
#[doc = "FSS0_OSPI_0_OSPI0_ECC_AGGR"]
pub struct Fss0Ospi0Ospi0EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fss0Ospi0Ospi0EccAggr {}
impl Fss0Ospi0Ospi0EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fss0_ospi_0_ospi0_ecc_aggr::RegisterBlock = 0x0071_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fss0_ospi_0_ospi0_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fss0Ospi0Ospi0EccAggr {
    type Target = fss0_ospi_0_ospi0_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fss0Ospi0Ospi0EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fss0Ospi0Ospi0EccAggr").finish()
    }
}
#[doc = "FSS0_OSPI_0_OSPI0_ECC_AGGR"]
pub mod fss0_ospi_0_ospi0_ecc_aggr;
#[doc = "A53SS0_SS_ECC_AGGR"]
pub struct A53ss0SsEccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0SsEccAggr {}
impl A53ss0SsEccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_ss_ecc_aggr::RegisterBlock = 0x0071_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_ss_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0SsEccAggr {
    type Target = a53ss0_ss_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0SsEccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0SsEccAggr").finish()
    }
}
#[doc = "A53SS0_SS_ECC_AGGR"]
pub mod a53ss0_ss_ecc_aggr;
#[doc = "A53SS0_CORE0_ECC_AGGR"]
pub struct A53ss0Core0EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0Core0EccAggr {}
impl A53ss0Core0EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_core0_ecc_aggr::RegisterBlock = 0x0071_7400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_core0_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0Core0EccAggr {
    type Target = a53ss0_core0_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0Core0EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0Core0EccAggr").finish()
    }
}
#[doc = "A53SS0_CORE0_ECC_AGGR"]
pub mod a53ss0_core0_ecc_aggr;
#[doc = "A53SS0_CORE1_ECC_AGGR"]
pub struct A53ss0Core1EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0Core1EccAggr {}
impl A53ss0Core1EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_core1_ecc_aggr::RegisterBlock = 0x0071_7800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_core1_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0Core1EccAggr {
    type Target = a53ss0_core1_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0Core1EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0Core1EccAggr").finish()
    }
}
#[doc = "A53SS0_CORE1_ECC_AGGR"]
pub mod a53ss0_core1_ecc_aggr;
#[doc = "ADC0_ECC_REGS"]
pub struct Adc0EccRegs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Adc0EccRegs {}
impl Adc0EccRegs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc0_ecc_regs::RegisterBlock = 0x0071_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc0_ecc_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Adc0EccRegs {
    type Target = adc0_ecc_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Adc0EccRegs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc0EccRegs").finish()
    }
}
#[doc = "ADC0_ECC_REGS"]
pub mod adc0_ecc_regs;
#[doc = "DCC0"]
pub struct Dcc0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dcc0 {}
impl Dcc0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dcc0::RegisterBlock = 0x0080_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dcc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dcc0 {
    type Target = dcc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dcc0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dcc0").finish()
    }
}
#[doc = "DCC0"]
pub mod dcc0;
#[doc = "DCC1"]
pub struct Dcc1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dcc1 {}
impl Dcc1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dcc1::RegisterBlock = 0x0080_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dcc1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dcc1 {
    type Target = dcc1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dcc1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dcc1").finish()
    }
}
#[doc = "DCC1"]
pub mod dcc1;
#[doc = "DCC2"]
pub struct Dcc2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dcc2 {}
impl Dcc2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dcc2::RegisterBlock = 0x0080_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dcc2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dcc2 {
    type Target = dcc2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dcc2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dcc2").finish()
    }
}
#[doc = "DCC2"]
pub mod dcc2;
#[doc = "DCC3"]
pub struct Dcc3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dcc3 {}
impl Dcc3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dcc3::RegisterBlock = 0x0080_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dcc3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dcc3 {
    type Target = dcc3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dcc3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dcc3").finish()
    }
}
#[doc = "DCC3"]
pub mod dcc3;
#[doc = "DCC4"]
pub struct Dcc4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dcc4 {}
impl Dcc4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dcc4::RegisterBlock = 0x0081_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dcc4::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dcc4 {
    type Target = dcc4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dcc4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dcc4").finish()
    }
}
#[doc = "DCC4"]
pub mod dcc4;
#[doc = "DCC5"]
pub struct Dcc5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dcc5 {}
impl Dcc5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dcc5::RegisterBlock = 0x0081_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dcc5::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dcc5 {
    type Target = dcc5::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dcc5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dcc5").finish()
    }
}
#[doc = "DCC5"]
pub mod dcc5;
#[doc = "MAIN_GPIOMUX_INTROUTER0_CFG"]
pub struct MainGpiomuxIntrouter0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MainGpiomuxIntrouter0Cfg {}
impl MainGpiomuxIntrouter0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const main_gpiomux_introuter0_cfg::RegisterBlock = 0x00a0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const main_gpiomux_introuter0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for MainGpiomuxIntrouter0Cfg {
    type Target = main_gpiomux_introuter0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MainGpiomuxIntrouter0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MainGpiomuxIntrouter0Cfg").finish()
    }
}
#[doc = "MAIN_GPIOMUX_INTROUTER0_CFG"]
pub mod main_gpiomux_introuter0_cfg;
#[doc = "CMP_EVENT_INTROUTER0_CFG"]
pub struct CmpEventIntrouter0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CmpEventIntrouter0Cfg {}
impl CmpEventIntrouter0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cmp_event_introuter0_cfg::RegisterBlock = 0x00a3_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cmp_event_introuter0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CmpEventIntrouter0Cfg {
    type Target = cmp_event_introuter0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CmpEventIntrouter0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CmpEventIntrouter0Cfg").finish()
    }
}
#[doc = "CMP_EVENT_INTROUTER0_CFG"]
pub mod cmp_event_introuter0_cfg;
#[doc = "TIMESYNC_EVENT_INTROUTER0_CFG"]
pub struct TimesyncEventIntrouter0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TimesyncEventIntrouter0Cfg {}
impl TimesyncEventIntrouter0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timesync_event_introuter0_cfg::RegisterBlock = 0x00a4_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timesync_event_introuter0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TimesyncEventIntrouter0Cfg {
    type Target = timesync_event_introuter0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TimesyncEventIntrouter0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TimesyncEventIntrouter0Cfg").finish()
    }
}
#[doc = "TIMESYNC_EVENT_INTROUTER0_CFG"]
pub mod timesync_event_introuter0_cfg;
#[doc = "GTC0_GTC_CFG0"]
pub struct Gtc0GtcCfg0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gtc0GtcCfg0 {}
impl Gtc0GtcCfg0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gtc0_gtc_cfg0::RegisterBlock = 0x00a8_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gtc0_gtc_cfg0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gtc0GtcCfg0 {
    type Target = gtc0_gtc_cfg0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gtc0GtcCfg0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gtc0GtcCfg0").finish()
    }
}
#[doc = "GTC0_GTC_CFG0"]
pub mod gtc0_gtc_cfg0;
#[doc = "GTC0_GTC_CFG1"]
pub struct Gtc0GtcCfg1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gtc0GtcCfg1 {}
impl Gtc0GtcCfg1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gtc0_gtc_cfg1::RegisterBlock = 0x00a9_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gtc0_gtc_cfg1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gtc0GtcCfg1 {
    type Target = gtc0_gtc_cfg1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gtc0GtcCfg1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gtc0GtcCfg1").finish()
    }
}
#[doc = "GTC0_GTC_CFG1"]
pub mod gtc0_gtc_cfg1;
#[doc = "GTC0_GTC_CFG2"]
pub struct Gtc0GtcCfg2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gtc0GtcCfg2 {}
impl Gtc0GtcCfg2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gtc0_gtc_cfg2::RegisterBlock = 0x00aa_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gtc0_gtc_cfg2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gtc0GtcCfg2 {
    type Target = gtc0_gtc_cfg2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gtc0GtcCfg2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gtc0GtcCfg2").finish()
    }
}
#[doc = "GTC0_GTC_CFG2"]
pub mod gtc0_gtc_cfg2;
#[doc = "GTC0_GTC_CFG3"]
pub struct Gtc0GtcCfg3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gtc0GtcCfg3 {}
impl Gtc0GtcCfg3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gtc0_gtc_cfg3::RegisterBlock = 0x00ab_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gtc0_gtc_cfg3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gtc0GtcCfg3 {
    type Target = gtc0_gtc_cfg3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gtc0GtcCfg3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gtc0GtcCfg3").finish()
    }
}
#[doc = "GTC0_GTC_CFG3"]
pub mod gtc0_gtc_cfg3;
#[doc = "VTM0_MMR_VBUSP_CFG1"]
pub struct Vtm0MmrVbuspCfg1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vtm0MmrVbuspCfg1 {}
impl Vtm0MmrVbuspCfg1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vtm0_mmr_vbusp_cfg1::RegisterBlock = 0x00b0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vtm0_mmr_vbusp_cfg1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vtm0MmrVbuspCfg1 {
    type Target = vtm0_mmr_vbusp_cfg1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vtm0MmrVbuspCfg1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vtm0MmrVbuspCfg1").finish()
    }
}
#[doc = "VTM0_MMR_VBUSP_CFG1"]
pub mod vtm0_mmr_vbusp_cfg1;
#[doc = "VTM0_MMR_VBUSP_CFG2"]
pub struct Vtm0MmrVbuspCfg2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vtm0MmrVbuspCfg2 {}
impl Vtm0MmrVbuspCfg2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vtm0_mmr_vbusp_cfg2::RegisterBlock = 0x00b0_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vtm0_mmr_vbusp_cfg2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vtm0MmrVbuspCfg2 {
    type Target = vtm0_mmr_vbusp_cfg2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vtm0MmrVbuspCfg2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vtm0MmrVbuspCfg2").finish()
    }
}
#[doc = "VTM0_MMR_VBUSP_CFG2"]
pub mod vtm0_mmr_vbusp_cfg2;
#[doc = "VTM0_ECCAGGR_CFG"]
pub struct Vtm0EccaggrCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Vtm0EccaggrCfg {}
impl Vtm0EccaggrCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vtm0_eccaggr_cfg::RegisterBlock = 0x00b0_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vtm0_eccaggr_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Vtm0EccaggrCfg {
    type Target = vtm0_eccaggr_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Vtm0EccaggrCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vtm0EccaggrCfg").finish()
    }
}
#[doc = "VTM0_ECCAGGR_CFG"]
pub mod vtm0_eccaggr_cfg;
#[doc = "PDMA0_REGS"]
pub struct Pdma0Regs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pdma0Regs {}
impl Pdma0Regs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pdma0_regs::RegisterBlock = 0x00c0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pdma0_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pdma0Regs {
    type Target = pdma0_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pdma0Regs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pdma0Regs").finish()
    }
}
#[doc = "PDMA0_REGS"]
pub mod pdma0_regs;
#[doc = "PDMA1_REGS"]
pub struct Pdma1Regs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pdma1Regs {}
impl Pdma1Regs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pdma1_regs::RegisterBlock = 0x00c0_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pdma1_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pdma1Regs {
    type Target = pdma1_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pdma1Regs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pdma1Regs").finish()
    }
}
#[doc = "PDMA1_REGS"]
pub mod pdma1_regs;
#[doc = "GICSS0_GIC_TRANSLATER"]
pub struct Gicss0GicTranslater {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gicss0GicTranslater {}
impl Gicss0GicTranslater {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gicss0_gic_translater::RegisterBlock = 0x0100_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gicss0_gic_translater::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gicss0GicTranslater {
    type Target = gicss0_gic_translater::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gicss0GicTranslater {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gicss0GicTranslater").finish()
    }
}
#[doc = "GICSS0_GIC_TRANSLATER"]
pub mod gicss0_gic_translater;
#[doc = "GICSS0_GIC"]
pub struct Gicss0Gic {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gicss0Gic {}
impl Gicss0Gic {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gicss0_gic::RegisterBlock = 0x0180_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gicss0_gic::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gicss0Gic {
    type Target = gicss0_gic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gicss0Gic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gicss0Gic").finish()
    }
}
#[doc = "GICSS0_GIC"]
pub mod gicss0_gic;
#[doc = "TIMER0_CFG"]
pub struct Timer0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer0Cfg {}
impl Timer0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0_cfg::RegisterBlock = 0x0240_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer0Cfg {
    type Target = timer0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer0Cfg").finish()
    }
}
#[doc = "TIMER0_CFG"]
pub mod timer0_cfg;
#[doc = "TIMER1_CFG"]
pub struct Timer1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer1Cfg {}
impl Timer1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer1_cfg::RegisterBlock = 0x0241_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer1Cfg {
    type Target = timer1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer1Cfg").finish()
    }
}
#[doc = "TIMER1_CFG"]
pub mod timer1_cfg;
#[doc = "TIMER2_CFG"]
pub struct Timer2Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer2Cfg {}
impl Timer2Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer2_cfg::RegisterBlock = 0x0242_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer2_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer2Cfg {
    type Target = timer2_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer2Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer2Cfg").finish()
    }
}
#[doc = "TIMER2_CFG"]
pub mod timer2_cfg;
#[doc = "TIMER3_CFG"]
pub struct Timer3Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer3Cfg {}
impl Timer3Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer3_cfg::RegisterBlock = 0x0243_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer3_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer3Cfg {
    type Target = timer3_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer3Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer3Cfg").finish()
    }
}
#[doc = "TIMER3_CFG"]
pub mod timer3_cfg;
#[doc = "TIMER4_CFG"]
pub struct Timer4Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer4Cfg {}
impl Timer4Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer4_cfg::RegisterBlock = 0x0244_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer4_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer4Cfg {
    type Target = timer4_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer4Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer4Cfg").finish()
    }
}
#[doc = "TIMER4_CFG"]
pub mod timer4_cfg;
#[doc = "TIMER5_CFG"]
pub struct Timer5Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer5Cfg {}
impl Timer5Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer5_cfg::RegisterBlock = 0x0245_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer5_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer5Cfg {
    type Target = timer5_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer5Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer5Cfg").finish()
    }
}
#[doc = "TIMER5_CFG"]
pub mod timer5_cfg;
#[doc = "TIMER6_CFG"]
pub struct Timer6Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer6Cfg {}
impl Timer6Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer6_cfg::RegisterBlock = 0x0246_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer6_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer6Cfg {
    type Target = timer6_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer6Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer6Cfg").finish()
    }
}
#[doc = "TIMER6_CFG"]
pub mod timer6_cfg;
#[doc = "TIMER7_CFG"]
pub struct Timer7Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer7Cfg {}
impl Timer7Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer7_cfg::RegisterBlock = 0x0247_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer7_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer7Cfg {
    type Target = timer7_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer7Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer7Cfg").finish()
    }
}
#[doc = "TIMER7_CFG"]
pub mod timer7_cfg;
#[doc = "TIMER8_CFG"]
pub struct Timer8Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer8Cfg {}
impl Timer8Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer8_cfg::RegisterBlock = 0x0248_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer8_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer8Cfg {
    type Target = timer8_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer8Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer8Cfg").finish()
    }
}
#[doc = "TIMER8_CFG"]
pub mod timer8_cfg;
#[doc = "TIMER9_CFG"]
pub struct Timer9Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer9Cfg {}
impl Timer9Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer9_cfg::RegisterBlock = 0x0249_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer9_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer9Cfg {
    type Target = timer9_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer9Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer9Cfg").finish()
    }
}
#[doc = "TIMER9_CFG"]
pub mod timer9_cfg;
#[doc = "TIMER10_CFG"]
pub struct Timer10Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer10Cfg {}
impl Timer10Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer10_cfg::RegisterBlock = 0x024a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer10_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer10Cfg {
    type Target = timer10_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer10Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer10Cfg").finish()
    }
}
#[doc = "TIMER10_CFG"]
pub mod timer10_cfg;
#[doc = "TIMER11_CFG"]
pub struct Timer11Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer11Cfg {}
impl Timer11Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer11_cfg::RegisterBlock = 0x024b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer11_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer11Cfg {
    type Target = timer11_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer11Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer11Cfg").finish()
    }
}
#[doc = "TIMER11_CFG"]
pub mod timer11_cfg;
#[doc = "UART0"]
pub struct Uart0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart0 {}
impl Uart0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x0280_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "UART0"]
pub mod uart0;
#[doc = "UART1"]
pub struct Uart1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart1 {}
impl Uart1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart1::RegisterBlock = 0x0281_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart1 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart1").finish()
    }
}
#[doc = "UART1"]
pub mod uart1;
#[doc = "UART2"]
pub struct Uart2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart2 {}
impl Uart2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart2::RegisterBlock = 0x0282_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart2 {
    type Target = uart2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart2").finish()
    }
}
#[doc = "UART2"]
pub mod uart2;
#[doc = "UART3"]
pub struct Uart3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart3 {}
impl Uart3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart3::RegisterBlock = 0x0283_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart3 {
    type Target = uart3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart3").finish()
    }
}
#[doc = "UART3"]
pub mod uart3;
#[doc = "UART4"]
pub struct Uart4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart4 {}
impl Uart4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart4::RegisterBlock = 0x0284_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart4::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart4 {
    type Target = uart4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart4").finish()
    }
}
#[doc = "UART4"]
pub mod uart4;
#[doc = "UART5"]
pub struct Uart5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart5 {}
impl Uart5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart5::RegisterBlock = 0x0285_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart5::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart5 {
    type Target = uart5::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart5").finish()
    }
}
#[doc = "UART5"]
pub mod uart5;
#[doc = "UART6"]
pub struct Uart6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uart6 {}
impl Uart6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart6::RegisterBlock = 0x0286_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart6::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uart6 {
    type Target = uart6::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uart6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart6").finish()
    }
}
#[doc = "UART6"]
pub mod uart6;
#[doc = "MCU_PSC0"]
pub struct McuPsc0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuPsc0 {}
impl McuPsc0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_psc0::RegisterBlock = 0x0400_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_psc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuPsc0 {
    type Target = mcu_psc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuPsc0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuPsc0").finish()
    }
}
#[doc = "MCU_PSC0"]
pub mod mcu_psc0;
#[doc = "MCU_PLL0_CFG"]
pub struct McuPll0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuPll0Cfg {}
impl McuPll0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_pll0_cfg::RegisterBlock = 0x0404_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_pll0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuPll0Cfg {
    type Target = mcu_pll0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuPll0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuPll0Cfg").finish()
    }
}
#[doc = "MCU_PLL0_CFG"]
pub mod mcu_pll0_cfg;
#[doc = "MCU_PADCFG_CTRL0_CFG0"]
pub struct McuPadcfgCtrl0Cfg0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuPadcfgCtrl0Cfg0 {}
impl McuPadcfgCtrl0Cfg0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_padcfg_ctrl0_cfg0::RegisterBlock = 0x0408_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_padcfg_ctrl0_cfg0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuPadcfgCtrl0Cfg0 {
    type Target = mcu_padcfg_ctrl0_cfg0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuPadcfgCtrl0Cfg0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuPadcfgCtrl0Cfg0").finish()
    }
}
#[doc = "MCU_PADCFG_CTRL0_CFG0"]
pub mod mcu_padcfg_ctrl0_cfg0;
#[doc = "MCU_ESM0_CFG"]
pub struct McuEsm0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuEsm0Cfg {}
impl McuEsm0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_esm0_cfg::RegisterBlock = 0x0410_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_esm0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuEsm0Cfg {
    type Target = mcu_esm0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuEsm0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuEsm0Cfg").finish()
    }
}
#[doc = "MCU_ESM0_CFG"]
pub mod mcu_esm0_cfg;
#[doc = "MCU_GPIO0"]
pub struct McuGpio0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuGpio0 {}
impl McuGpio0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_gpio0::RegisterBlock = 0x0420_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuGpio0 {
    type Target = mcu_gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuGpio0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuGpio0").finish()
    }
}
#[doc = "MCU_GPIO0"]
pub mod mcu_gpio0;
#[doc = "MCU_MCU_GPIOMUX_INTROUTER0_CFG"]
pub struct McuMcuGpiomuxIntrouter0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuMcuGpiomuxIntrouter0Cfg {}
impl McuMcuGpiomuxIntrouter0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_mcu_gpiomux_introuter0_cfg::RegisterBlock = 0x0421_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_mcu_gpiomux_introuter0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuMcuGpiomuxIntrouter0Cfg {
    type Target = mcu_mcu_gpiomux_introuter0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuMcuGpiomuxIntrouter0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuMcuGpiomuxIntrouter0Cfg").finish()
    }
}
#[doc = "MCU_MCU_GPIOMUX_INTROUTER0_CFG"]
pub mod mcu_mcu_gpiomux_introuter0_cfg;
#[doc = "MCU_TIMEOUT0_CFG"]
pub struct McuTimeout0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuTimeout0Cfg {}
impl McuTimeout0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_timeout0_cfg::RegisterBlock = 0x0430_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_timeout0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuTimeout0Cfg {
    type Target = mcu_timeout0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuTimeout0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuTimeout0Cfg").finish()
    }
}
#[doc = "MCU_TIMEOUT0_CFG"]
pub mod mcu_timeout0_cfg;
#[doc = "MCU_CTRL_MMR0_CFG0"]
pub struct McuCtrlMmr0Cfg0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuCtrlMmr0Cfg0 {}
impl McuCtrlMmr0Cfg0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_ctrl_mmr0_cfg0::RegisterBlock = 0x0450_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_ctrl_mmr0_cfg0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuCtrlMmr0Cfg0 {
    type Target = mcu_ctrl_mmr0_cfg0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuCtrlMmr0Cfg0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuCtrlMmr0Cfg0").finish()
    }
}
#[doc = "MCU_CTRL_MMR0_CFG0"]
pub mod mcu_ctrl_mmr0_cfg0;
#[doc = "MCU_ECC_AGGR0_ECC_AGGR"]
pub struct McuEccAggr0EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuEccAggr0EccAggr {}
impl McuEccAggr0EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_ecc_aggr0_ecc_aggr::RegisterBlock = 0x0470_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_ecc_aggr0_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuEccAggr0EccAggr {
    type Target = mcu_ecc_aggr0_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuEccAggr0EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuEccAggr0EccAggr").finish()
    }
}
#[doc = "MCU_ECC_AGGR0_ECC_AGGR"]
pub mod mcu_ecc_aggr0_ecc_aggr;
#[doc = "MCU_CBASS0_ERR"]
pub struct McuCbass0Err {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuCbass0Err {}
impl McuCbass0Err {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_cbass0_err::RegisterBlock = 0x0472_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_cbass0_err::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuCbass0Err {
    type Target = mcu_cbass0_err::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuCbass0Err {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuCbass0Err").finish()
    }
}
#[doc = "MCU_CBASS0_ERR"]
pub mod mcu_cbass0_err;
#[doc = "MCU_TIMER0_CFG"]
pub struct McuTimer0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuTimer0Cfg {}
impl McuTimer0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_timer0_cfg::RegisterBlock = 0x0480_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_timer0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuTimer0Cfg {
    type Target = mcu_timer0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuTimer0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuTimer0Cfg").finish()
    }
}
#[doc = "MCU_TIMER0_CFG"]
pub mod mcu_timer0_cfg;
#[doc = "MCU_TIMER1_CFG"]
pub struct McuTimer1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuTimer1Cfg {}
impl McuTimer1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_timer1_cfg::RegisterBlock = 0x0481_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_timer1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuTimer1Cfg {
    type Target = mcu_timer1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuTimer1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuTimer1Cfg").finish()
    }
}
#[doc = "MCU_TIMER1_CFG"]
pub mod mcu_timer1_cfg;
#[doc = "MCU_TIMER2_CFG"]
pub struct McuTimer2Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuTimer2Cfg {}
impl McuTimer2Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_timer2_cfg::RegisterBlock = 0x0482_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_timer2_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuTimer2Cfg {
    type Target = mcu_timer2_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuTimer2Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuTimer2Cfg").finish()
    }
}
#[doc = "MCU_TIMER2_CFG"]
pub mod mcu_timer2_cfg;
#[doc = "MCU_TIMER3_CFG"]
pub struct McuTimer3Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuTimer3Cfg {}
impl McuTimer3Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_timer3_cfg::RegisterBlock = 0x0483_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_timer3_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuTimer3Cfg {
    type Target = mcu_timer3_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuTimer3Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuTimer3Cfg").finish()
    }
}
#[doc = "MCU_TIMER3_CFG"]
pub mod mcu_timer3_cfg;
#[doc = "MCU_RTI0_CFG"]
pub struct McuRti0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuRti0Cfg {}
impl McuRti0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_rti0_cfg::RegisterBlock = 0x0488_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_rti0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuRti0Cfg {
    type Target = mcu_rti0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuRti0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuRti0Cfg").finish()
    }
}
#[doc = "MCU_RTI0_CFG"]
pub mod mcu_rti0_cfg;
#[doc = "MCU_I2C0_CFG"]
pub struct McuI2c0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuI2c0Cfg {}
impl McuI2c0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_i2c0_cfg::RegisterBlock = 0x0490_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_i2c0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuI2c0Cfg {
    type Target = mcu_i2c0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuI2c0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuI2c0Cfg").finish()
    }
}
#[doc = "MCU_I2C0_CFG"]
pub mod mcu_i2c0_cfg;
#[doc = "MCU_I2C1_CFG"]
pub struct McuI2c1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuI2c1Cfg {}
impl McuI2c1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_i2c1_cfg::RegisterBlock = 0x0491_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_i2c1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuI2c1Cfg {
    type Target = mcu_i2c1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuI2c1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuI2c1Cfg").finish()
    }
}
#[doc = "MCU_I2C1_CFG"]
pub mod mcu_i2c1_cfg;
#[doc = "MCU_UART0"]
pub struct McuUart0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuUart0 {}
impl McuUart0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_uart0::RegisterBlock = 0x04a0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuUart0 {
    type Target = mcu_uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuUart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuUart0").finish()
    }
}
#[doc = "MCU_UART0"]
pub mod mcu_uart0;
#[doc = "MCU_UART1"]
pub struct McuUart1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuUart1 {}
impl McuUart1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_uart1::RegisterBlock = 0x04a1_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_uart1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuUart1 {
    type Target = mcu_uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuUart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuUart1").finish()
    }
}
#[doc = "MCU_UART1"]
pub mod mcu_uart1;
#[doc = "MCU_MCSPI0_CFG"]
pub struct McuMcspi0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuMcspi0Cfg {}
impl McuMcspi0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_mcspi0_cfg::RegisterBlock = 0x04b0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_mcspi0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuMcspi0Cfg {
    type Target = mcu_mcspi0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuMcspi0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuMcspi0Cfg").finish()
    }
}
#[doc = "MCU_MCSPI0_CFG"]
pub mod mcu_mcspi0_cfg;
#[doc = "MCU_MCSPI1_CFG"]
pub struct McuMcspi1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuMcspi1Cfg {}
impl McuMcspi1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_mcspi1_cfg::RegisterBlock = 0x04b1_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_mcspi1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuMcspi1Cfg {
    type Target = mcu_mcspi1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuMcspi1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuMcspi1Cfg").finish()
    }
}
#[doc = "MCU_MCSPI1_CFG"]
pub mod mcu_mcspi1_cfg;
#[doc = "MCU_DCC0"]
pub struct McuDcc0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuDcc0 {}
impl McuDcc0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_dcc0::RegisterBlock = 0x04c0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_dcc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuDcc0 {
    type Target = mcu_dcc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuDcc0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuDcc0").finish()
    }
}
#[doc = "MCU_DCC0"]
pub mod mcu_dcc0;
#[doc = "MCU_MCRC64_0_REGS"]
pub struct McuMcrc64_0Regs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuMcrc64_0Regs {}
impl McuMcrc64_0Regs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_mcrc64_0_regs::RegisterBlock = 0x04d0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_mcrc64_0_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuMcrc64_0Regs {
    type Target = mcu_mcrc64_0_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuMcrc64_0Regs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuMcrc64_0Regs").finish()
    }
}
#[doc = "MCU_MCRC64_0_REGS"]
pub mod mcu_mcrc64_0_regs;
#[doc = "MCU_M4FSS0_IRAM_0_IRAM"]
pub struct McuM4fss0Iram0Iram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuM4fss0Iram0Iram {}
impl McuM4fss0Iram0Iram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_m4fss0_iram_0_iram::RegisterBlock = 0x0500_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_m4fss0_iram_0_iram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuM4fss0Iram0Iram {
    type Target = mcu_m4fss0_iram_0_iram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuM4fss0Iram0Iram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuM4fss0Iram0Iram").finish()
    }
}
#[doc = "MCU_M4FSS0_IRAM_0_IRAM"]
pub mod mcu_m4fss0_iram_0_iram;
#[doc = "MCU_M4FSS0_DRAM_0_DRAM"]
pub struct McuM4fss0Dram0Dram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuM4fss0Dram0Dram {}
impl McuM4fss0Dram0Dram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_m4fss0_dram_0_dram::RegisterBlock = 0x0504_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_m4fss0_dram_0_dram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuM4fss0Dram0Dram {
    type Target = mcu_m4fss0_dram_0_dram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuM4fss0Dram0Dram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuM4fss0Dram0Dram").finish()
    }
}
#[doc = "MCU_M4FSS0_DRAM_0_DRAM"]
pub mod mcu_m4fss0_dram_0_dram;
#[doc = "MCU_M4FSS0_RAT_0_RAT"]
pub struct McuM4fss0Rat0Rat {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuM4fss0Rat0Rat {}
impl McuM4fss0Rat0Rat {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_m4fss0_rat_0_rat::RegisterBlock = 0x05ff_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_m4fss0_rat_0_rat::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuM4fss0Rat0Rat {
    type Target = mcu_m4fss0_rat_0_rat::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuM4fss0Rat0Rat {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuM4fss0Rat0Rat").finish()
    }
}
#[doc = "MCU_M4FSS0_RAT_0_RAT"]
pub mod mcu_m4fss0_rat_0_rat;
#[doc = "MCU_M4FSS0_ECC_AGGR_0_ECC_AGGR"]
pub struct McuM4fss0EccAggr0EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuM4fss0EccAggr0EccAggr {}
impl McuM4fss0EccAggr0EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_m4fss0_ecc_aggr_0_ecc_aggr::RegisterBlock = 0x05ff_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_m4fss0_ecc_aggr_0_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuM4fss0EccAggr0EccAggr {
    type Target = mcu_m4fss0_ecc_aggr_0_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuM4fss0EccAggr0EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuM4fss0EccAggr0EccAggr").finish()
    }
}
#[doc = "MCU_M4FSS0_ECC_AGGR_0_ECC_AGGR"]
pub mod mcu_m4fss0_ecc_aggr_0_ecc_aggr;
#[doc = "CPSW0_NUSS"]
pub struct Cpsw0Nuss {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cpsw0Nuss {}
impl Cpsw0Nuss {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpsw0_nuss::RegisterBlock = 0x0800_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpsw0_nuss::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cpsw0Nuss {
    type Target = cpsw0_nuss::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cpsw0Nuss {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cpsw0Nuss").finish()
    }
}
#[doc = "CPSW0_NUSS"]
pub mod cpsw0_nuss;
#[doc = "RTI0_CFG"]
pub struct Rti0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rti0Cfg {}
impl Rti0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rti0_cfg::RegisterBlock = 0x0e00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rti0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rti0Cfg {
    type Target = rti0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rti0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rti0Cfg").finish()
    }
}
#[doc = "RTI0_CFG"]
pub mod rti0_cfg;
#[doc = "RTI1_CFG"]
pub struct Rti1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rti1Cfg {}
impl Rti1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rti1_cfg::RegisterBlock = 0x0e01_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rti1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rti1Cfg {
    type Target = rti1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rti1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rti1Cfg").finish()
    }
}
#[doc = "RTI1_CFG"]
pub mod rti1_cfg;
#[doc = "RTI8_CFG"]
pub struct Rti8Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rti8Cfg {}
impl Rti8Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rti8_cfg::RegisterBlock = 0x0e08_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rti8_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rti8Cfg {
    type Target = rti8_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rti8Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rti8Cfg").finish()
    }
}
#[doc = "RTI8_CFG"]
pub mod rti8_cfg;
#[doc = "RTI9_CFG"]
pub struct Rti9Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rti9Cfg {}
impl Rti9Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rti9_cfg::RegisterBlock = 0x0e09_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rti9_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rti9Cfg {
    type Target = rti9_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rti9Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rti9Cfg").finish()
    }
}
#[doc = "RTI9_CFG"]
pub mod rti9_cfg;
#[doc = "RTI10_CFG"]
pub struct Rti10Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rti10Cfg {}
impl Rti10Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rti10_cfg::RegisterBlock = 0x0e0a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rti10_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rti10Cfg {
    type Target = rti10_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rti10Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rti10Cfg").finish()
    }
}
#[doc = "RTI10_CFG"]
pub mod rti10_cfg;
#[doc = "RTI11_CFG"]
pub struct Rti11Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rti11Cfg {}
impl Rti11Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rti11_cfg::RegisterBlock = 0x0e0b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rti11_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rti11Cfg {
    type Target = rti11_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rti11Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rti11Cfg").finish()
    }
}
#[doc = "RTI11_CFG"]
pub mod rti11_cfg;
#[doc = "DDR16SS0_SS_CFG"]
pub struct Ddr16ss0SsCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ddr16ss0SsCfg {}
impl Ddr16ss0SsCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ddr16ss0_ss_cfg::RegisterBlock = 0x0f30_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ddr16ss0_ss_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ddr16ss0SsCfg {
    type Target = ddr16ss0_ss_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ddr16ss0SsCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ddr16ss0SsCfg").finish()
    }
}
#[doc = "DDR16SS0_SS_CFG"]
pub mod ddr16ss0_ss_cfg;
#[doc = "DDR16SS0_CTLPHY_WRAP_CTL_CFG_CTLCFG"]
pub struct Ddr16ss0CtlphyWrapCtlCfgCtlcfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ddr16ss0CtlphyWrapCtlCfgCtlcfg {}
impl Ddr16ss0CtlphyWrapCtlCfgCtlcfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ddr16ss0_ctlphy_wrap_ctl_cfg_ctlcfg::RegisterBlock =
        0x0f30_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ddr16ss0_ctlphy_wrap_ctl_cfg_ctlcfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ddr16ss0CtlphyWrapCtlCfgCtlcfg {
    type Target = ddr16ss0_ctlphy_wrap_ctl_cfg_ctlcfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ddr16ss0CtlphyWrapCtlCfgCtlcfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ddr16ss0CtlphyWrapCtlCfgCtlcfg").finish()
    }
}
#[doc = "DDR16SS0_CTLPHY_WRAP_CTL_CFG_CTLCFG"]
pub mod ddr16ss0_ctlphy_wrap_ctl_cfg_ctlcfg;
#[doc = "MMCSD1_CTL_CFG"]
pub struct Mmcsd1CtlCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmcsd1CtlCfg {}
impl Mmcsd1CtlCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmcsd1_ctl_cfg::RegisterBlock = 0x0fa0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmcsd1_ctl_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmcsd1CtlCfg {
    type Target = mmcsd1_ctl_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmcsd1CtlCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmcsd1CtlCfg").finish()
    }
}
#[doc = "MMCSD1_CTL_CFG"]
pub mod mmcsd1_ctl_cfg;
#[doc = "MMCSD1_SS_CFG"]
pub struct Mmcsd1SsCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmcsd1SsCfg {}
impl Mmcsd1SsCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmcsd1_ss_cfg::RegisterBlock = 0x0fa0_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmcsd1_ss_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmcsd1SsCfg {
    type Target = mmcsd1_ss_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmcsd1SsCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmcsd1SsCfg").finish()
    }
}
#[doc = "MMCSD1_SS_CFG"]
pub mod mmcsd1_ss_cfg;
#[doc = "MMCSD0_CTL_CFG"]
pub struct Mmcsd0CtlCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmcsd0CtlCfg {}
impl Mmcsd0CtlCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmcsd0_ctl_cfg::RegisterBlock = 0x0fa1_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmcsd0_ctl_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmcsd0CtlCfg {
    type Target = mmcsd0_ctl_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmcsd0CtlCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmcsd0CtlCfg").finish()
    }
}
#[doc = "MMCSD0_CTL_CFG"]
pub mod mmcsd0_ctl_cfg;
#[doc = "MMCSD0_SS_CFG"]
pub struct Mmcsd0SsCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mmcsd0SsCfg {}
impl Mmcsd0SsCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mmcsd0_ss_cfg::RegisterBlock = 0x0fa1_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mmcsd0_ss_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mmcsd0SsCfg {
    type Target = mmcsd0_ss_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mmcsd0SsCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mmcsd0SsCfg").finish()
    }
}
#[doc = "MMCSD0_SS_CFG"]
pub mod mmcsd0_ss_cfg;
#[doc = "FSS0_CFG"]
pub struct Fss0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fss0Cfg {}
impl Fss0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fss0_cfg::RegisterBlock = 0x0fc0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fss0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fss0Cfg {
    type Target = fss0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fss0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fss0Cfg").finish()
    }
}
#[doc = "FSS0_CFG"]
pub mod fss0_cfg;
#[doc = "FSS0_FSAS_0_FSAS_CFG"]
pub struct Fss0Fsas0FsasCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fss0Fsas0FsasCfg {}
impl Fss0Fsas0FsasCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fss0_fsas_0_fsas_cfg::RegisterBlock = 0x0fc1_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fss0_fsas_0_fsas_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fss0Fsas0FsasCfg {
    type Target = fss0_fsas_0_fsas_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fss0Fsas0FsasCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fss0Fsas0FsasCfg").finish()
    }
}
#[doc = "FSS0_FSAS_0_FSAS_CFG"]
pub mod fss0_fsas_0_fsas_cfg;
#[doc = "FSS0_FSAS_0_OTFA_CFG"]
pub struct Fss0Fsas0OtfaCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fss0Fsas0OtfaCfg {}
impl Fss0Fsas0OtfaCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fss0_fsas_0_otfa_cfg::RegisterBlock = 0x0fc2_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fss0_fsas_0_otfa_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fss0Fsas0OtfaCfg {
    type Target = fss0_fsas_0_otfa_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fss0Fsas0OtfaCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fss0Fsas0OtfaCfg").finish()
    }
}
#[doc = "FSS0_FSAS_0_OTFA_CFG"]
pub mod fss0_fsas_0_otfa_cfg;
#[doc = "FSS0_OSPI_0_OSPI0_CTRL"]
pub struct Fss0Ospi0Ospi0Ctrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fss0Ospi0Ospi0Ctrl {}
impl Fss0Ospi0Ospi0Ctrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fss0_ospi_0_ospi0_ctrl::RegisterBlock = 0x0fc4_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fss0_ospi_0_ospi0_ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fss0Ospi0Ospi0Ctrl {
    type Target = fss0_ospi_0_ospi0_ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fss0Ospi0Ospi0Ctrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fss0Ospi0Ospi0Ctrl").finish()
    }
}
#[doc = "FSS0_OSPI_0_OSPI0_CTRL"]
pub mod fss0_ospi_0_ospi0_ctrl;
#[doc = "FSS0_OSPI_0_OSPI0_SS_CFG"]
pub struct Fss0Ospi0Ospi0SsCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fss0Ospi0Ospi0SsCfg {}
impl Fss0Ospi0Ospi0SsCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fss0_ospi_0_ospi0_ss_cfg::RegisterBlock = 0x0fc4_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fss0_ospi_0_ospi0_ss_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fss0Ospi0Ospi0SsCfg {
    type Target = fss0_ospi_0_ospi0_ss_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fss0Ospi0Ospi0SsCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fss0Ospi0Ospi0SsCfg").finish()
    }
}
#[doc = "FSS0_OSPI_0_OSPI0_SS_CFG"]
pub mod fss0_ospi_0_ospi0_ss_cfg;
#[doc = "I2C0_CFG"]
pub struct I2c0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c0Cfg {}
impl I2c0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c0_cfg::RegisterBlock = 0x2000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c0Cfg {
    type Target = i2c0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c0Cfg").finish()
    }
}
#[doc = "I2C0_CFG"]
pub mod i2c0_cfg;
#[doc = "I2C1_CFG"]
pub struct I2c1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c1Cfg {}
impl I2c1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c1_cfg::RegisterBlock = 0x2001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c1Cfg {
    type Target = i2c1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c1Cfg").finish()
    }
}
#[doc = "I2C1_CFG"]
pub mod i2c1_cfg;
#[doc = "I2C2_CFG"]
pub struct I2c2Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c2Cfg {}
impl I2c2Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c2_cfg::RegisterBlock = 0x2002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c2_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c2Cfg {
    type Target = i2c2_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c2Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c2Cfg").finish()
    }
}
#[doc = "I2C2_CFG"]
pub mod i2c2_cfg;
#[doc = "I2C3_CFG"]
pub struct I2c3Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c3Cfg {}
impl I2c3Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c3_cfg::RegisterBlock = 0x2003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c3_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c3Cfg {
    type Target = i2c3_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c3Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c3Cfg").finish()
    }
}
#[doc = "I2C3_CFG"]
pub mod i2c3_cfg;
#[doc = "MCSPI0_CFG"]
pub struct Mcspi0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcspi0Cfg {}
impl Mcspi0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcspi0_cfg::RegisterBlock = 0x2010_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcspi0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcspi0Cfg {
    type Target = mcspi0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcspi0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcspi0Cfg").finish()
    }
}
#[doc = "MCSPI0_CFG"]
pub mod mcspi0_cfg;
#[doc = "MCSPI1_CFG"]
pub struct Mcspi1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcspi1Cfg {}
impl Mcspi1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcspi1_cfg::RegisterBlock = 0x2011_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcspi1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcspi1Cfg {
    type Target = mcspi1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcspi1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcspi1Cfg").finish()
    }
}
#[doc = "MCSPI1_CFG"]
pub mod mcspi1_cfg;
#[doc = "MCSPI2_CFG"]
pub struct Mcspi2Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcspi2Cfg {}
impl Mcspi2Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcspi2_cfg::RegisterBlock = 0x2012_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcspi2_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcspi2Cfg {
    type Target = mcspi2_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcspi2Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcspi2Cfg").finish()
    }
}
#[doc = "MCSPI2_CFG"]
pub mod mcspi2_cfg;
#[doc = "MCSPI3_CFG"]
pub struct Mcspi3Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcspi3Cfg {}
impl Mcspi3Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcspi3_cfg::RegisterBlock = 0x2013_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcspi3_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcspi3Cfg {
    type Target = mcspi3_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcspi3Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcspi3Cfg").finish()
    }
}
#[doc = "MCSPI3_CFG"]
pub mod mcspi3_cfg;
#[doc = "MCSPI4_CFG"]
pub struct Mcspi4Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcspi4Cfg {}
impl Mcspi4Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcspi4_cfg::RegisterBlock = 0x2014_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcspi4_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcspi4Cfg {
    type Target = mcspi4_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcspi4Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcspi4Cfg").finish()
    }
}
#[doc = "MCSPI4_CFG"]
pub mod mcspi4_cfg;
#[doc = "MCAN0_SS"]
pub struct Mcan0Ss {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcan0Ss {}
impl Mcan0Ss {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcan0_ss::RegisterBlock = 0x2070_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcan0_ss::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcan0Ss {
    type Target = mcan0_ss::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcan0Ss {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcan0Ss").finish()
    }
}
#[doc = "MCAN0_SS"]
pub mod mcan0_ss;
#[doc = "MCAN0_CFG"]
pub struct Mcan0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcan0Cfg {}
impl Mcan0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcan0_cfg::RegisterBlock = 0x2070_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcan0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcan0Cfg {
    type Target = mcan0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcan0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcan0Cfg").finish()
    }
}
#[doc = "MCAN0_CFG"]
pub mod mcan0_cfg;
#[doc = "MCAN1_SS"]
pub struct Mcan1Ss {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcan1Ss {}
impl Mcan1Ss {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcan1_ss::RegisterBlock = 0x2071_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcan1_ss::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcan1Ss {
    type Target = mcan1_ss::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcan1Ss {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcan1Ss").finish()
    }
}
#[doc = "MCAN1_SS"]
pub mod mcan1_ss;
#[doc = "MCAN1_CFG"]
pub struct Mcan1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcan1Cfg {}
impl Mcan1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcan1_cfg::RegisterBlock = 0x2071_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcan1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcan1Cfg {
    type Target = mcan1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcan1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcan1Cfg").finish()
    }
}
#[doc = "MCAN1_CFG"]
pub mod mcan1_cfg;
#[doc = "EPWM0_EPWM"]
pub struct Epwm0Epwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Epwm0Epwm {}
impl Epwm0Epwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const epwm0_epwm::RegisterBlock = 0x2300_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const epwm0_epwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Epwm0Epwm {
    type Target = epwm0_epwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Epwm0Epwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Epwm0Epwm").finish()
    }
}
#[doc = "EPWM0_EPWM"]
pub mod epwm0_epwm;
#[doc = "EPWM1_EPWM"]
pub struct Epwm1Epwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Epwm1Epwm {}
impl Epwm1Epwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const epwm1_epwm::RegisterBlock = 0x2301_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const epwm1_epwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Epwm1Epwm {
    type Target = epwm1_epwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Epwm1Epwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Epwm1Epwm").finish()
    }
}
#[doc = "EPWM1_EPWM"]
pub mod epwm1_epwm;
#[doc = "EPWM2_EPWM"]
pub struct Epwm2Epwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Epwm2Epwm {}
impl Epwm2Epwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const epwm2_epwm::RegisterBlock = 0x2302_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const epwm2_epwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Epwm2Epwm {
    type Target = epwm2_epwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Epwm2Epwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Epwm2Epwm").finish()
    }
}
#[doc = "EPWM2_EPWM"]
pub mod epwm2_epwm;
#[doc = "EPWM3_EPWM"]
pub struct Epwm3Epwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Epwm3Epwm {}
impl Epwm3Epwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const epwm3_epwm::RegisterBlock = 0x2303_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const epwm3_epwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Epwm3Epwm {
    type Target = epwm3_epwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Epwm3Epwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Epwm3Epwm").finish()
    }
}
#[doc = "EPWM3_EPWM"]
pub mod epwm3_epwm;
#[doc = "EPWM4_EPWM"]
pub struct Epwm4Epwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Epwm4Epwm {}
impl Epwm4Epwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const epwm4_epwm::RegisterBlock = 0x2304_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const epwm4_epwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Epwm4Epwm {
    type Target = epwm4_epwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Epwm4Epwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Epwm4Epwm").finish()
    }
}
#[doc = "EPWM4_EPWM"]
pub mod epwm4_epwm;
#[doc = "EPWM5_EPWM"]
pub struct Epwm5Epwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Epwm5Epwm {}
impl Epwm5Epwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const epwm5_epwm::RegisterBlock = 0x2305_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const epwm5_epwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Epwm5Epwm {
    type Target = epwm5_epwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Epwm5Epwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Epwm5Epwm").finish()
    }
}
#[doc = "EPWM5_EPWM"]
pub mod epwm5_epwm;
#[doc = "EPWM6_EPWM"]
pub struct Epwm6Epwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Epwm6Epwm {}
impl Epwm6Epwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const epwm6_epwm::RegisterBlock = 0x2306_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const epwm6_epwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Epwm6Epwm {
    type Target = epwm6_epwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Epwm6Epwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Epwm6Epwm").finish()
    }
}
#[doc = "EPWM6_EPWM"]
pub mod epwm6_epwm;
#[doc = "EPWM7_EPWM"]
pub struct Epwm7Epwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Epwm7Epwm {}
impl Epwm7Epwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const epwm7_epwm::RegisterBlock = 0x2307_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const epwm7_epwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Epwm7Epwm {
    type Target = epwm7_epwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Epwm7Epwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Epwm7Epwm").finish()
    }
}
#[doc = "EPWM7_EPWM"]
pub mod epwm7_epwm;
#[doc = "EPWM8_EPWM"]
pub struct Epwm8Epwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Epwm8Epwm {}
impl Epwm8Epwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const epwm8_epwm::RegisterBlock = 0x2308_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const epwm8_epwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Epwm8Epwm {
    type Target = epwm8_epwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Epwm8Epwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Epwm8Epwm").finish()
    }
}
#[doc = "EPWM8_EPWM"]
pub mod epwm8_epwm;
#[doc = "ECAP0_CTL_STS"]
pub struct Ecap0CtlSts {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecap0CtlSts {}
impl Ecap0CtlSts {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecap0_ctl_sts::RegisterBlock = 0x2310_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecap0_ctl_sts::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ecap0CtlSts {
    type Target = ecap0_ctl_sts::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecap0CtlSts {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecap0CtlSts").finish()
    }
}
#[doc = "ECAP0_CTL_STS"]
pub mod ecap0_ctl_sts;
#[doc = "ECAP1_CTL_STS"]
pub struct Ecap1CtlSts {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecap1CtlSts {}
impl Ecap1CtlSts {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecap1_ctl_sts::RegisterBlock = 0x2311_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecap1_ctl_sts::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ecap1CtlSts {
    type Target = ecap1_ctl_sts::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecap1CtlSts {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecap1CtlSts").finish()
    }
}
#[doc = "ECAP1_CTL_STS"]
pub mod ecap1_ctl_sts;
#[doc = "ECAP2_CTL_STS"]
pub struct Ecap2CtlSts {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ecap2CtlSts {}
impl Ecap2CtlSts {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecap2_ctl_sts::RegisterBlock = 0x2312_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecap2_ctl_sts::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ecap2CtlSts {
    type Target = ecap2_ctl_sts::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ecap2CtlSts {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecap2CtlSts").finish()
    }
}
#[doc = "ECAP2_CTL_STS"]
pub mod ecap2_ctl_sts;
#[doc = "EQEP0_REG"]
pub struct Eqep0Reg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eqep0Reg {}
impl Eqep0Reg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eqep0_reg::RegisterBlock = 0x2320_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eqep0_reg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Eqep0Reg {
    type Target = eqep0_reg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eqep0Reg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eqep0Reg").finish()
    }
}
#[doc = "EQEP0_REG"]
pub mod eqep0_reg;
#[doc = "EQEP1_REG"]
pub struct Eqep1Reg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eqep1Reg {}
impl Eqep1Reg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eqep1_reg::RegisterBlock = 0x2321_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eqep1_reg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Eqep1Reg {
    type Target = eqep1_reg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eqep1Reg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eqep1Reg").finish()
    }
}
#[doc = "EQEP1_REG"]
pub mod eqep1_reg;
#[doc = "EQEP2_REG"]
pub struct Eqep2Reg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eqep2Reg {}
impl Eqep2Reg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eqep2_reg::RegisterBlock = 0x2322_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eqep2_reg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Eqep2Reg {
    type Target = eqep2_reg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eqep2Reg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eqep2Reg").finish()
    }
}
#[doc = "EQEP2_REG"]
pub mod eqep2_reg;
#[doc = "FSIRX0_CFG"]
pub struct Fsirx0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fsirx0Cfg {}
impl Fsirx0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fsirx0_cfg::RegisterBlock = 0x2350_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsirx0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fsirx0Cfg {
    type Target = fsirx0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fsirx0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fsirx0Cfg").finish()
    }
}
#[doc = "FSIRX0_CFG"]
pub mod fsirx0_cfg;
#[doc = "FSIRX1_CFG"]
pub struct Fsirx1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fsirx1Cfg {}
impl Fsirx1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fsirx1_cfg::RegisterBlock = 0x2351_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsirx1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fsirx1Cfg {
    type Target = fsirx1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fsirx1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fsirx1Cfg").finish()
    }
}
#[doc = "FSIRX1_CFG"]
pub mod fsirx1_cfg;
#[doc = "FSIRX2_CFG"]
pub struct Fsirx2Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fsirx2Cfg {}
impl Fsirx2Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fsirx2_cfg::RegisterBlock = 0x2352_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsirx2_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fsirx2Cfg {
    type Target = fsirx2_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fsirx2Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fsirx2Cfg").finish()
    }
}
#[doc = "FSIRX2_CFG"]
pub mod fsirx2_cfg;
#[doc = "FSIRX3_CFG"]
pub struct Fsirx3Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fsirx3Cfg {}
impl Fsirx3Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fsirx3_cfg::RegisterBlock = 0x2353_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsirx3_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fsirx3Cfg {
    type Target = fsirx3_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fsirx3Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fsirx3Cfg").finish()
    }
}
#[doc = "FSIRX3_CFG"]
pub mod fsirx3_cfg;
#[doc = "FSIRX4_CFG"]
pub struct Fsirx4Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fsirx4Cfg {}
impl Fsirx4Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fsirx4_cfg::RegisterBlock = 0x2354_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsirx4_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fsirx4Cfg {
    type Target = fsirx4_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fsirx4Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fsirx4Cfg").finish()
    }
}
#[doc = "FSIRX4_CFG"]
pub mod fsirx4_cfg;
#[doc = "FSIRX5_CFG"]
pub struct Fsirx5Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fsirx5Cfg {}
impl Fsirx5Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fsirx5_cfg::RegisterBlock = 0x2355_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsirx5_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fsirx5Cfg {
    type Target = fsirx5_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fsirx5Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fsirx5Cfg").finish()
    }
}
#[doc = "FSIRX5_CFG"]
pub mod fsirx5_cfg;
#[doc = "FSITX0_CFG"]
pub struct Fsitx0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fsitx0Cfg {}
impl Fsitx0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fsitx0_cfg::RegisterBlock = 0x2360_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsitx0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fsitx0Cfg {
    type Target = fsitx0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fsitx0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fsitx0Cfg").finish()
    }
}
#[doc = "FSITX0_CFG"]
pub mod fsitx0_cfg;
#[doc = "FSITX1_CFG"]
pub struct Fsitx1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fsitx1Cfg {}
impl Fsitx1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fsitx1_cfg::RegisterBlock = 0x2361_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fsitx1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fsitx1Cfg {
    type Target = fsitx1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fsitx1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fsitx1Cfg").finish()
    }
}
#[doc = "FSITX1_CFG"]
pub mod fsitx1_cfg;
#[doc = "MCAN0_ECC_AGGR"]
pub struct Mcan0EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcan0EccAggr {}
impl Mcan0EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcan0_ecc_aggr::RegisterBlock = 0x2401_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcan0_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcan0EccAggr {
    type Target = mcan0_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcan0EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcan0EccAggr").finish()
    }
}
#[doc = "MCAN0_ECC_AGGR"]
pub mod mcan0_ecc_aggr;
#[doc = "MCAN1_ECC_AGGR"]
pub struct Mcan1EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mcan1EccAggr {}
impl Mcan1EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcan1_ecc_aggr::RegisterBlock = 0x2401_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcan1_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mcan1EccAggr {
    type Target = mcan1_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mcan1EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcan1EccAggr").finish()
    }
}
#[doc = "MCAN1_ECC_AGGR"]
pub mod mcan1_ecc_aggr;
#[doc = "ELM0"]
pub struct Elm0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Elm0 {}
impl Elm0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const elm0::RegisterBlock = 0x2501_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const elm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Elm0 {
    type Target = elm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Elm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Elm0").finish()
    }
}
#[doc = "ELM0"]
pub mod elm0;
#[doc = "ADC0_FIFO"]
pub struct Adc0Fifo {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Adc0Fifo {}
impl Adc0Fifo {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc0_fifo::RegisterBlock = 0x2800_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc0_fifo::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Adc0Fifo {
    type Target = adc0_fifo::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Adc0Fifo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc0Fifo").finish()
    }
}
#[doc = "ADC0_FIFO"]
pub mod adc0_fifo;
#[doc = "ADC0"]
pub struct Adc0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Adc0 {}
impl Adc0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc0::RegisterBlock = 0x2800_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Adc0 {
    type Target = adc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Adc0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc0").finish()
    }
}
#[doc = "ADC0"]
pub mod adc0;
#[doc = "MAILBOX0_MAILBOX_CLUSTER_0_REGS0"]
pub struct Mailbox0MailboxCluster0Regs0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox0MailboxCluster0Regs0 {}
impl Mailbox0MailboxCluster0Regs0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox0_mailbox_cluster_0_regs0::RegisterBlock = 0x2900_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox0_mailbox_cluster_0_regs0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox0MailboxCluster0Regs0 {
    type Target = mailbox0_mailbox_cluster_0_regs0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox0MailboxCluster0Regs0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox0MailboxCluster0Regs0").finish()
    }
}
#[doc = "MAILBOX0_MAILBOX_CLUSTER_0_REGS0"]
pub mod mailbox0_mailbox_cluster_0_regs0;
#[doc = "MAILBOX0_MAILBOX_CLUSTER_1_REGS1"]
pub struct Mailbox0MailboxCluster1Regs1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox0MailboxCluster1Regs1 {}
impl Mailbox0MailboxCluster1Regs1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox0_mailbox_cluster_1_regs1::RegisterBlock = 0x2901_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox0_mailbox_cluster_1_regs1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox0MailboxCluster1Regs1 {
    type Target = mailbox0_mailbox_cluster_1_regs1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox0MailboxCluster1Regs1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox0MailboxCluster1Regs1").finish()
    }
}
#[doc = "MAILBOX0_MAILBOX_CLUSTER_1_REGS1"]
pub mod mailbox0_mailbox_cluster_1_regs1;
#[doc = "MAILBOX0_MAILBOX_CLUSTER_2_REGS2"]
pub struct Mailbox0MailboxCluster2Regs2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox0MailboxCluster2Regs2 {}
impl Mailbox0MailboxCluster2Regs2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox0_mailbox_cluster_2_regs2::RegisterBlock = 0x2902_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox0_mailbox_cluster_2_regs2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox0MailboxCluster2Regs2 {
    type Target = mailbox0_mailbox_cluster_2_regs2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox0MailboxCluster2Regs2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox0MailboxCluster2Regs2").finish()
    }
}
#[doc = "MAILBOX0_MAILBOX_CLUSTER_2_REGS2"]
pub mod mailbox0_mailbox_cluster_2_regs2;
#[doc = "MAILBOX0_MAILBOX_CLUSTER_3_REGS3"]
pub struct Mailbox0MailboxCluster3Regs3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox0MailboxCluster3Regs3 {}
impl Mailbox0MailboxCluster3Regs3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox0_mailbox_cluster_3_regs3::RegisterBlock = 0x2903_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox0_mailbox_cluster_3_regs3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox0MailboxCluster3Regs3 {
    type Target = mailbox0_mailbox_cluster_3_regs3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox0MailboxCluster3Regs3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox0MailboxCluster3Regs3").finish()
    }
}
#[doc = "MAILBOX0_MAILBOX_CLUSTER_3_REGS3"]
pub mod mailbox0_mailbox_cluster_3_regs3;
#[doc = "MAILBOX0_MAILBOX_CLUSTER_4_REGS4"]
pub struct Mailbox0MailboxCluster4Regs4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox0MailboxCluster4Regs4 {}
impl Mailbox0MailboxCluster4Regs4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox0_mailbox_cluster_4_regs4::RegisterBlock = 0x2904_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox0_mailbox_cluster_4_regs4::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox0MailboxCluster4Regs4 {
    type Target = mailbox0_mailbox_cluster_4_regs4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox0MailboxCluster4Regs4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox0MailboxCluster4Regs4").finish()
    }
}
#[doc = "MAILBOX0_MAILBOX_CLUSTER_4_REGS4"]
pub mod mailbox0_mailbox_cluster_4_regs4;
#[doc = "MAILBOX0_MAILBOX_CLUSTER_5_REGS5"]
pub struct Mailbox0MailboxCluster5Regs5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox0MailboxCluster5Regs5 {}
impl Mailbox0MailboxCluster5Regs5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox0_mailbox_cluster_5_regs5::RegisterBlock = 0x2905_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox0_mailbox_cluster_5_regs5::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox0MailboxCluster5Regs5 {
    type Target = mailbox0_mailbox_cluster_5_regs5::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox0MailboxCluster5Regs5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox0MailboxCluster5Regs5").finish()
    }
}
#[doc = "MAILBOX0_MAILBOX_CLUSTER_5_REGS5"]
pub mod mailbox0_mailbox_cluster_5_regs5;
#[doc = "MAILBOX0_MAILBOX_CLUSTER_6_REGS6"]
pub struct Mailbox0MailboxCluster6Regs6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox0MailboxCluster6Regs6 {}
impl Mailbox0MailboxCluster6Regs6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox0_mailbox_cluster_6_regs6::RegisterBlock = 0x2906_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox0_mailbox_cluster_6_regs6::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox0MailboxCluster6Regs6 {
    type Target = mailbox0_mailbox_cluster_6_regs6::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox0MailboxCluster6Regs6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox0MailboxCluster6Regs6").finish()
    }
}
#[doc = "MAILBOX0_MAILBOX_CLUSTER_6_REGS6"]
pub mod mailbox0_mailbox_cluster_6_regs6;
#[doc = "MAILBOX0_MAILBOX_CLUSTER_7_REGS7"]
pub struct Mailbox0MailboxCluster7Regs7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mailbox0MailboxCluster7Regs7 {}
impl Mailbox0MailboxCluster7Regs7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mailbox0_mailbox_cluster_7_regs7::RegisterBlock = 0x2907_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mailbox0_mailbox_cluster_7_regs7::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mailbox0MailboxCluster7Regs7 {
    type Target = mailbox0_mailbox_cluster_7_regs7::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mailbox0MailboxCluster7Regs7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mailbox0MailboxCluster7Regs7").finish()
    }
}
#[doc = "MAILBOX0_MAILBOX_CLUSTER_7_REGS7"]
pub mod mailbox0_mailbox_cluster_7_regs7;
#[doc = "SPINLOCK0"]
pub struct Spinlock0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spinlock0 {}
impl Spinlock0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spinlock0::RegisterBlock = 0x2a00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spinlock0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spinlock0 {
    type Target = spinlock0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spinlock0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spinlock0").finish()
    }
}
#[doc = "SPINLOCK0"]
pub mod spinlock0;
#[doc = "PRU_ICSSG0_DRAM0_SLV_RAM"]
pub struct PruIcssg0Dram0SlvRam {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Dram0SlvRam {}
impl PruIcssg0Dram0SlvRam {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_dram0_slv_ram::RegisterBlock = 0x3000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_dram0_slv_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Dram0SlvRam {
    type Target = pru_icssg0_dram0_slv_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Dram0SlvRam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Dram0SlvRam").finish()
    }
}
#[doc = "PRU_ICSSG0_DRAM0_SLV_RAM"]
pub mod pru_icssg0_dram0_slv_ram;
#[doc = "PRU_ICSSG0_DRAM1_SLV_RAM"]
pub struct PruIcssg0Dram1SlvRam {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Dram1SlvRam {}
impl PruIcssg0Dram1SlvRam {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_dram1_slv_ram::RegisterBlock = 0x3000_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_dram1_slv_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Dram1SlvRam {
    type Target = pru_icssg0_dram1_slv_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Dram1SlvRam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Dram1SlvRam").finish()
    }
}
#[doc = "PRU_ICSSG0_DRAM1_SLV_RAM"]
pub mod pru_icssg0_dram1_slv_ram;
#[doc = "PRU_ICSSG0_RAT_SLICE0_CFG"]
pub struct PruIcssg0RatSlice0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0RatSlice0Cfg {}
impl PruIcssg0RatSlice0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_rat_slice0_cfg::RegisterBlock = 0x3000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_rat_slice0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0RatSlice0Cfg {
    type Target = pru_icssg0_rat_slice0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0RatSlice0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0RatSlice0Cfg").finish()
    }
}
#[doc = "PRU_ICSSG0_RAT_SLICE0_CFG"]
pub mod pru_icssg0_rat_slice0_cfg;
#[doc = "PRU_ICSSG0_RAT_SLICE1_CFG"]
pub struct PruIcssg0RatSlice1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0RatSlice1Cfg {}
impl PruIcssg0RatSlice1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_rat_slice1_cfg::RegisterBlock = 0x3000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_rat_slice1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0RatSlice1Cfg {
    type Target = pru_icssg0_rat_slice1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0RatSlice1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0RatSlice1Cfg").finish()
    }
}
#[doc = "PRU_ICSSG0_RAT_SLICE1_CFG"]
pub mod pru_icssg0_rat_slice1_cfg;
#[doc = "PRU_ICSSG0_RAM_SLV_RAM"]
pub struct PruIcssg0RamSlvRam {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0RamSlvRam {}
impl PruIcssg0RamSlvRam {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_ram_slv_ram::RegisterBlock = 0x3001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_ram_slv_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0RamSlvRam {
    type Target = pru_icssg0_ram_slv_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0RamSlvRam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0RamSlvRam").finish()
    }
}
#[doc = "PRU_ICSSG0_RAM_SLV_RAM"]
pub mod pru_icssg0_ram_slv_ram;
#[doc = "PRU_ICSSG0_PR1_ICSS_INTC_INTC_SLV"]
pub struct PruIcssg0Pr1IcssIntcIntcSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1IcssIntcIntcSlv {}
impl PruIcssg0Pr1IcssIntcIntcSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_icss_intc_intc_slv::RegisterBlock =
        0x3002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_icss_intc_intc_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1IcssIntcIntcSlv {
    type Target = pru_icssg0_pr1_icss_intc_intc_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1IcssIntcIntcSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1IcssIntcIntcSlv").finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_ICSS_INTC_INTC_SLV"]
pub mod pru_icssg0_pr1_icss_intc_intc_slv;
#[doc = "PRU_ICSSG0_PR1_PROT_SLV"]
pub struct PruIcssg0Pr1ProtSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1ProtSlv {}
impl PruIcssg0Pr1ProtSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_prot_slv::RegisterBlock = 0x3002_4c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_prot_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1ProtSlv {
    type Target = pru_icssg0_pr1_prot_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1ProtSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1ProtSlv").finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_PROT_SLV"]
pub mod pru_icssg0_pr1_prot_slv;
#[doc = "PRU_ICSSG0_PR1_CFG_SLV"]
pub struct PruIcssg0Pr1CfgSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1CfgSlv {}
impl PruIcssg0Pr1CfgSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_cfg_slv::RegisterBlock = 0x3002_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_cfg_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1CfgSlv {
    type Target = pru_icssg0_pr1_cfg_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1CfgSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1CfgSlv").finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_CFG_SLV"]
pub mod pru_icssg0_pr1_cfg_slv;
#[doc = "PRU_ICSSG0_PA_STAT_WRAP_PA_SLV_QSTAT"]
pub struct PruIcssg0PaStatWrapPaSlvQstat {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0PaStatWrapPaSlvQstat {}
impl PruIcssg0PaStatWrapPaSlvQstat {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pa_stat_wrap_pa_slv_qstat::RegisterBlock =
        0x3002_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pa_stat_wrap_pa_slv_qstat::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0PaStatWrapPaSlvQstat {
    type Target = pru_icssg0_pa_stat_wrap_pa_slv_qstat::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0PaStatWrapPaSlvQstat {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0PaStatWrapPaSlvQstat").finish()
    }
}
#[doc = "PRU_ICSSG0_PA_STAT_WRAP_PA_SLV_QSTAT"]
pub mod pru_icssg0_pa_stat_wrap_pa_slv_qstat;
#[doc = "PRU_ICSSG0_PR1_ICSS_UART_UART_SLV"]
pub struct PruIcssg0Pr1IcssUartUartSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1IcssUartUartSlv {}
impl PruIcssg0Pr1IcssUartUartSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_icss_uart_uart_slv::RegisterBlock =
        0x3002_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_icss_uart_uart_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1IcssUartUartSlv {
    type Target = pru_icssg0_pr1_icss_uart_uart_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1IcssUartUartSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1IcssUartUartSlv").finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_ICSS_UART_UART_SLV"]
pub mod pru_icssg0_pr1_icss_uart_uart_slv;
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU0_PR1_TASKS_MGR_PRU0_MMR"]
pub struct PruIcssg0Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {}
impl PruIcssg0Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr::RegisterBlock =
        0x3002_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr::RegisterBlock
    {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {
    type Target = pru_icssg0_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU0_PR1_TASKS_MGR_PRU0_MMR"]
pub mod pru_icssg0_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr;
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_RTU0_PR1_TASKS_MGR_RTU0_MMR"]
pub struct PruIcssg0Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {}
impl PruIcssg0Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr::RegisterBlock =
        0x3002_a100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr::RegisterBlock
    {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {
    type Target = pru_icssg0_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_RTU0_PR1_TASKS_MGR_RTU0_MMR"]
pub mod pru_icssg0_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr;
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU1_PR1_TASKS_MGR_PRU1_MMR"]
pub struct PruIcssg0Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {}
impl PruIcssg0Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr::RegisterBlock =
        0x3002_a200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr::RegisterBlock
    {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {
    type Target = pru_icssg0_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU1_PR1_TASKS_MGR_PRU1_MMR"]
pub mod pru_icssg0_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr;
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_RTU1_PR1_TASKS_MGR_RTU1_MMR"]
pub struct PruIcssg0Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {}
impl PruIcssg0Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr::RegisterBlock =
        0x3002_a300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr::RegisterBlock
    {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {
    type Target = pru_icssg0_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_RTU1_PR1_TASKS_MGR_RTU1_MMR"]
pub mod pru_icssg0_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr;
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU_TX0_PR1_TASKS_MGR_PRU_TX0_MMR"]
pub struct PruIcssg0Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {}
impl PruIcssg0Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR:
        *const pru_icssg0_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr::RegisterBlock =
        0x3002_a400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr(
    ) -> *const pru_icssg0_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {
    type Target = pru_icssg0_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU_TX0_PR1_TASKS_MGR_PRU_TX0_MMR"]
pub mod pru_icssg0_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr;
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU_TX1_PR1_TASKS_MGR_PRU_TX1_MMR"]
pub struct PruIcssg0Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {}
impl PruIcssg0Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR:
        *const pru_icssg0_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr::RegisterBlock =
        0x3002_a500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr(
    ) -> *const pru_icssg0_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {
    type Target = pru_icssg0_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU_TX1_PR1_TASKS_MGR_PRU_TX1_MMR"]
pub mod pru_icssg0_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr;
#[doc = "PRU_ICSSG0_PA_STAT_WRAP_PA_SLV_CSTAT"]
pub struct PruIcssg0PaStatWrapPaSlvCstat {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0PaStatWrapPaSlvCstat {}
impl PruIcssg0PaStatWrapPaSlvCstat {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pa_stat_wrap_pa_slv_cstat::RegisterBlock =
        0x3002_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pa_stat_wrap_pa_slv_cstat::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0PaStatWrapPaSlvCstat {
    type Target = pru_icssg0_pa_stat_wrap_pa_slv_cstat::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0PaStatWrapPaSlvCstat {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0PaStatWrapPaSlvCstat").finish()
    }
}
#[doc = "PRU_ICSSG0_PA_STAT_WRAP_PA_SLV_CSTAT"]
pub mod pru_icssg0_pa_stat_wrap_pa_slv_cstat;
#[doc = "PRU_ICSSG0_IEP0"]
pub struct PruIcssg0Iep0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Iep0 {}
impl PruIcssg0Iep0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_iep0::RegisterBlock = 0x3002_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_iep0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Iep0 {
    type Target = pru_icssg0_iep0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Iep0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Iep0").finish()
    }
}
#[doc = "PRU_ICSSG0_IEP0"]
pub mod pru_icssg0_iep0;
#[doc = "PRU_ICSSG0_IEP1"]
pub struct PruIcssg0Iep1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Iep1 {}
impl PruIcssg0Iep1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_iep1::RegisterBlock = 0x3002_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_iep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Iep1 {
    type Target = pru_icssg0_iep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Iep1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Iep1").finish()
    }
}
#[doc = "PRU_ICSSG0_IEP1"]
pub mod pru_icssg0_iep1;
#[doc = "PRU_ICSSG0_PR1_ICSS_ECAP0_ECAP_SLV"]
pub struct PruIcssg0Pr1IcssEcap0EcapSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1IcssEcap0EcapSlv {}
impl PruIcssg0Pr1IcssEcap0EcapSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_icss_ecap0_ecap_slv::RegisterBlock =
        0x3003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_icss_ecap0_ecap_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1IcssEcap0EcapSlv {
    type Target = pru_icssg0_pr1_icss_ecap0_ecap_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1IcssEcap0EcapSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1IcssEcap0EcapSlv").finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_ICSS_ECAP0_ECAP_SLV"]
pub mod pru_icssg0_pr1_icss_ecap0_ecap_slv;
#[doc = "PRU_ICSSG0_PR1_MII_RT_PR1_MII_RT_CFG"]
pub struct PruIcssg0Pr1MiiRtPr1MiiRtCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1MiiRtPr1MiiRtCfg {}
impl PruIcssg0Pr1MiiRtPr1MiiRtCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_mii_rt_pr1_mii_rt_cfg::RegisterBlock =
        0x3003_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_mii_rt_pr1_mii_rt_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1MiiRtPr1MiiRtCfg {
    type Target = pru_icssg0_pr1_mii_rt_pr1_mii_rt_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1MiiRtPr1MiiRtCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1MiiRtPr1MiiRtCfg").finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_MII_RT_PR1_MII_RT_CFG"]
pub mod pru_icssg0_pr1_mii_rt_pr1_mii_rt_cfg;
#[doc = "PRU_ICSSG0_PR1_MDIO_V1P7_MDIO"]
pub struct PruIcssg0Pr1MdioV1p7Mdio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1MdioV1p7Mdio {}
impl PruIcssg0Pr1MdioV1p7Mdio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_mdio_v1p7_mdio::RegisterBlock = 0x3003_2400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_mdio_v1p7_mdio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1MdioV1p7Mdio {
    type Target = pru_icssg0_pr1_mdio_v1p7_mdio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1MdioV1p7Mdio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1MdioV1p7Mdio").finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_MDIO_V1P7_MDIO"]
pub mod pru_icssg0_pr1_mdio_v1p7_mdio;
#[doc = "PRU_ICSSG0_PR1_MII_RT_PR1_MII_RT_G_CFG_REGS_G"]
pub struct PruIcssg0Pr1MiiRtPr1MiiRtGCfgRegsG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0Pr1MiiRtPr1MiiRtGCfgRegsG {}
impl PruIcssg0Pr1MiiRtPr1MiiRtGCfgRegsG {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g::RegisterBlock =
        0x3003_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0Pr1MiiRtPr1MiiRtGCfgRegsG {
    type Target = pru_icssg0_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0Pr1MiiRtPr1MiiRtGCfgRegsG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0Pr1MiiRtPr1MiiRtGCfgRegsG")
            .finish()
    }
}
#[doc = "PRU_ICSSG0_PR1_MII_RT_PR1_MII_RT_G_CFG_REGS_G"]
pub mod pru_icssg0_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g;
#[doc = "PRU_ICSSG1_DRAM0_SLV_RAM"]
pub struct PruIcssg1Dram0SlvRam {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Dram0SlvRam {}
impl PruIcssg1Dram0SlvRam {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_dram0_slv_ram::RegisterBlock = 0x3008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_dram0_slv_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Dram0SlvRam {
    type Target = pru_icssg1_dram0_slv_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Dram0SlvRam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Dram0SlvRam").finish()
    }
}
#[doc = "PRU_ICSSG1_DRAM0_SLV_RAM"]
pub mod pru_icssg1_dram0_slv_ram;
#[doc = "PRU_ICSSG1_DRAM1_SLV_RAM"]
pub struct PruIcssg1Dram1SlvRam {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Dram1SlvRam {}
impl PruIcssg1Dram1SlvRam {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_dram1_slv_ram::RegisterBlock = 0x3008_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_dram1_slv_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Dram1SlvRam {
    type Target = pru_icssg1_dram1_slv_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Dram1SlvRam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Dram1SlvRam").finish()
    }
}
#[doc = "PRU_ICSSG1_DRAM1_SLV_RAM"]
pub mod pru_icssg1_dram1_slv_ram;
#[doc = "PRU_ICSSG1_RAT_SLICE0_CFG"]
pub struct PruIcssg1RatSlice0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1RatSlice0Cfg {}
impl PruIcssg1RatSlice0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_rat_slice0_cfg::RegisterBlock = 0x3008_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_rat_slice0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1RatSlice0Cfg {
    type Target = pru_icssg1_rat_slice0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1RatSlice0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1RatSlice0Cfg").finish()
    }
}
#[doc = "PRU_ICSSG1_RAT_SLICE0_CFG"]
pub mod pru_icssg1_rat_slice0_cfg;
#[doc = "PRU_ICSSG1_RAT_SLICE1_CFG"]
pub struct PruIcssg1RatSlice1Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1RatSlice1Cfg {}
impl PruIcssg1RatSlice1Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_rat_slice1_cfg::RegisterBlock = 0x3008_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_rat_slice1_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1RatSlice1Cfg {
    type Target = pru_icssg1_rat_slice1_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1RatSlice1Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1RatSlice1Cfg").finish()
    }
}
#[doc = "PRU_ICSSG1_RAT_SLICE1_CFG"]
pub mod pru_icssg1_rat_slice1_cfg;
#[doc = "PRU_ICSSG1_RAM_SLV_RAM"]
pub struct PruIcssg1RamSlvRam {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1RamSlvRam {}
impl PruIcssg1RamSlvRam {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_ram_slv_ram::RegisterBlock = 0x3009_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_ram_slv_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1RamSlvRam {
    type Target = pru_icssg1_ram_slv_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1RamSlvRam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1RamSlvRam").finish()
    }
}
#[doc = "PRU_ICSSG1_RAM_SLV_RAM"]
pub mod pru_icssg1_ram_slv_ram;
#[doc = "PRU_ICSSG1_PR1_ICSS_INTC_INTC_SLV"]
pub struct PruIcssg1Pr1IcssIntcIntcSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1IcssIntcIntcSlv {}
impl PruIcssg1Pr1IcssIntcIntcSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_icss_intc_intc_slv::RegisterBlock =
        0x300a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_icss_intc_intc_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1IcssIntcIntcSlv {
    type Target = pru_icssg1_pr1_icss_intc_intc_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1IcssIntcIntcSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1IcssIntcIntcSlv").finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_ICSS_INTC_INTC_SLV"]
pub mod pru_icssg1_pr1_icss_intc_intc_slv;
#[doc = "PRU_ICSSG1_PR1_PROT_SLV"]
pub struct PruIcssg1Pr1ProtSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1ProtSlv {}
impl PruIcssg1Pr1ProtSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_prot_slv::RegisterBlock = 0x300a_4c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_prot_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1ProtSlv {
    type Target = pru_icssg1_pr1_prot_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1ProtSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1ProtSlv").finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_PROT_SLV"]
pub mod pru_icssg1_pr1_prot_slv;
#[doc = "PRU_ICSSG1_PR1_CFG_SLV"]
pub struct PruIcssg1Pr1CfgSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1CfgSlv {}
impl PruIcssg1Pr1CfgSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_cfg_slv::RegisterBlock = 0x300a_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_cfg_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1CfgSlv {
    type Target = pru_icssg1_pr1_cfg_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1CfgSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1CfgSlv").finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_CFG_SLV"]
pub mod pru_icssg1_pr1_cfg_slv;
#[doc = "PRU_ICSSG1_PA_STAT_WRAP_PA_SLV_QSTAT"]
pub struct PruIcssg1PaStatWrapPaSlvQstat {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1PaStatWrapPaSlvQstat {}
impl PruIcssg1PaStatWrapPaSlvQstat {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pa_stat_wrap_pa_slv_qstat::RegisterBlock =
        0x300a_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pa_stat_wrap_pa_slv_qstat::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1PaStatWrapPaSlvQstat {
    type Target = pru_icssg1_pa_stat_wrap_pa_slv_qstat::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1PaStatWrapPaSlvQstat {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1PaStatWrapPaSlvQstat").finish()
    }
}
#[doc = "PRU_ICSSG1_PA_STAT_WRAP_PA_SLV_QSTAT"]
pub mod pru_icssg1_pa_stat_wrap_pa_slv_qstat;
#[doc = "PRU_ICSSG1_PR1_ICSS_UART_UART_SLV"]
pub struct PruIcssg1Pr1IcssUartUartSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1IcssUartUartSlv {}
impl PruIcssg1Pr1IcssUartUartSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_icss_uart_uart_slv::RegisterBlock =
        0x300a_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_icss_uart_uart_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1IcssUartUartSlv {
    type Target = pru_icssg1_pr1_icss_uart_uart_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1IcssUartUartSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1IcssUartUartSlv").finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_ICSS_UART_UART_SLV"]
pub mod pru_icssg1_pr1_icss_uart_uart_slv;
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU0_PR1_TASKS_MGR_PRU0_MMR"]
pub struct PruIcssg1Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {}
impl PruIcssg1Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr::RegisterBlock =
        0x300a_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr::RegisterBlock
    {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {
    type Target = pru_icssg1_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU0_PR1_TASKS_MGR_PRU0_MMR"]
pub mod pru_icssg1_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr;
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_RTU0_PR1_TASKS_MGR_RTU0_MMR"]
pub struct PruIcssg1Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {}
impl PruIcssg1Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr::RegisterBlock =
        0x300a_a100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr::RegisterBlock
    {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {
    type Target = pru_icssg1_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_RTU0_PR1_TASKS_MGR_RTU0_MMR"]
pub mod pru_icssg1_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr;
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU1_PR1_TASKS_MGR_PRU1_MMR"]
pub struct PruIcssg1Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {}
impl PruIcssg1Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr::RegisterBlock =
        0x300a_a200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr::RegisterBlock
    {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {
    type Target = pru_icssg1_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU1_PR1_TASKS_MGR_PRU1_MMR"]
pub mod pru_icssg1_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr;
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_RTU1_PR1_TASKS_MGR_RTU1_MMR"]
pub struct PruIcssg1Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {}
impl PruIcssg1Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr::RegisterBlock =
        0x300a_a300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr::RegisterBlock
    {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {
    type Target = pru_icssg1_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_RTU1_PR1_TASKS_MGR_RTU1_MMR"]
pub mod pru_icssg1_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr;
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU_TX0_PR1_TASKS_MGR_PRU_TX0_MMR"]
pub struct PruIcssg1Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {}
impl PruIcssg1Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR:
        *const pru_icssg1_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr::RegisterBlock =
        0x300a_a400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr(
    ) -> *const pru_icssg1_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {
    type Target = pru_icssg1_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU_TX0_PR1_TASKS_MGR_PRU_TX0_MMR"]
pub mod pru_icssg1_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr;
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU_TX1_PR1_TASKS_MGR_PRU_TX1_MMR"]
pub struct PruIcssg1Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {}
impl PruIcssg1Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {
    #[doc = r"Pointer to the register block"]
    pub const PTR:
        *const pru_icssg1_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr::RegisterBlock =
        0x300a_a500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr(
    ) -> *const pru_icssg1_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {
    type Target = pru_icssg1_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr")
            .finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU_TX1_PR1_TASKS_MGR_PRU_TX1_MMR"]
pub mod pru_icssg1_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr;
#[doc = "PRU_ICSSG1_PA_STAT_WRAP_PA_SLV_CSTAT"]
pub struct PruIcssg1PaStatWrapPaSlvCstat {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1PaStatWrapPaSlvCstat {}
impl PruIcssg1PaStatWrapPaSlvCstat {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pa_stat_wrap_pa_slv_cstat::RegisterBlock =
        0x300a_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pa_stat_wrap_pa_slv_cstat::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1PaStatWrapPaSlvCstat {
    type Target = pru_icssg1_pa_stat_wrap_pa_slv_cstat::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1PaStatWrapPaSlvCstat {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1PaStatWrapPaSlvCstat").finish()
    }
}
#[doc = "PRU_ICSSG1_PA_STAT_WRAP_PA_SLV_CSTAT"]
pub mod pru_icssg1_pa_stat_wrap_pa_slv_cstat;
#[doc = "PRU_ICSSG1_IEP0"]
pub struct PruIcssg1Iep0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Iep0 {}
impl PruIcssg1Iep0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_iep0::RegisterBlock = 0x300a_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_iep0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Iep0 {
    type Target = pru_icssg1_iep0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Iep0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Iep0").finish()
    }
}
#[doc = "PRU_ICSSG1_IEP0"]
pub mod pru_icssg1_iep0;
#[doc = "PRU_ICSSG1_IEP1"]
pub struct PruIcssg1Iep1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Iep1 {}
impl PruIcssg1Iep1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_iep1::RegisterBlock = 0x300a_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_iep1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Iep1 {
    type Target = pru_icssg1_iep1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Iep1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Iep1").finish()
    }
}
#[doc = "PRU_ICSSG1_IEP1"]
pub mod pru_icssg1_iep1;
#[doc = "PRU_ICSSG1_PR1_ICSS_ECAP0_ECAP_SLV"]
pub struct PruIcssg1Pr1IcssEcap0EcapSlv {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1IcssEcap0EcapSlv {}
impl PruIcssg1Pr1IcssEcap0EcapSlv {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_icss_ecap0_ecap_slv::RegisterBlock =
        0x300b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_icss_ecap0_ecap_slv::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1IcssEcap0EcapSlv {
    type Target = pru_icssg1_pr1_icss_ecap0_ecap_slv::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1IcssEcap0EcapSlv {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1IcssEcap0EcapSlv").finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_ICSS_ECAP0_ECAP_SLV"]
pub mod pru_icssg1_pr1_icss_ecap0_ecap_slv;
#[doc = "PRU_ICSSG1_PR1_MII_RT_PR1_MII_RT_CFG"]
pub struct PruIcssg1Pr1MiiRtPr1MiiRtCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1MiiRtPr1MiiRtCfg {}
impl PruIcssg1Pr1MiiRtPr1MiiRtCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_mii_rt_pr1_mii_rt_cfg::RegisterBlock =
        0x300b_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_mii_rt_pr1_mii_rt_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1MiiRtPr1MiiRtCfg {
    type Target = pru_icssg1_pr1_mii_rt_pr1_mii_rt_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1MiiRtPr1MiiRtCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1MiiRtPr1MiiRtCfg").finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_MII_RT_PR1_MII_RT_CFG"]
pub mod pru_icssg1_pr1_mii_rt_pr1_mii_rt_cfg;
#[doc = "PRU_ICSSG1_PR1_MDIO_V1P7_MDIO"]
pub struct PruIcssg1Pr1MdioV1p7Mdio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1MdioV1p7Mdio {}
impl PruIcssg1Pr1MdioV1p7Mdio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_mdio_v1p7_mdio::RegisterBlock = 0x300b_2400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_mdio_v1p7_mdio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1MdioV1p7Mdio {
    type Target = pru_icssg1_pr1_mdio_v1p7_mdio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1MdioV1p7Mdio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1MdioV1p7Mdio").finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_MDIO_V1P7_MDIO"]
pub mod pru_icssg1_pr1_mdio_v1p7_mdio;
#[doc = "PRU_ICSSG1_PR1_MII_RT_PR1_MII_RT_G_CFG_REGS_G"]
pub struct PruIcssg1Pr1MiiRtPr1MiiRtGCfgRegsG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1Pr1MiiRtPr1MiiRtGCfgRegsG {}
impl PruIcssg1Pr1MiiRtPr1MiiRtGCfgRegsG {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g::RegisterBlock =
        0x300b_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1Pr1MiiRtPr1MiiRtGCfgRegsG {
    type Target = pru_icssg1_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1Pr1MiiRtPr1MiiRtGCfgRegsG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1Pr1MiiRtPr1MiiRtGCfgRegsG")
            .finish()
    }
}
#[doc = "PRU_ICSSG1_PR1_MII_RT_PR1_MII_RT_G_CFG_REGS_G"]
pub mod pru_icssg1_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g;
#[doc = "TIMERMGR0_TIMERS"]
pub struct Timermgr0Timers {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timermgr0Timers {}
impl Timermgr0Timers {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timermgr0_timers::RegisterBlock = 0x3700_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timermgr0_timers::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timermgr0Timers {
    type Target = timermgr0_timers::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timermgr0Timers {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timermgr0Timers").finish()
    }
}
#[doc = "TIMERMGR0_TIMERS"]
pub mod timermgr0_timers;
#[doc = "CPTS0"]
pub struct Cpts0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cpts0 {}
impl Cpts0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpts0::RegisterBlock = 0x3900_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpts0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cpts0 {
    type Target = cpts0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cpts0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cpts0").finish()
    }
}
#[doc = "CPTS0"]
pub mod cpts0;
#[doc = "CBASS0_ERR"]
pub struct Cbass0Err {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cbass0Err {}
impl Cbass0Err {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass0_err::RegisterBlock = 0x3a00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass0_err::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cbass0Err {
    type Target = cbass0_err::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cbass0Err {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cbass0Err").finish()
    }
}
#[doc = "CBASS0_ERR"]
pub mod cbass0_err;
#[doc = "GPMC0_CFG"]
pub struct Gpmc0Cfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpmc0Cfg {}
impl Gpmc0Cfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpmc0_cfg::RegisterBlock = 0x3b00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpmc0_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpmc0Cfg {
    type Target = gpmc0_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpmc0Cfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpmc0Cfg").finish()
    }
}
#[doc = "GPMC0_CFG"]
pub mod gpmc0_cfg;
#[doc = "TIMERMGR0_CONFIG"]
pub struct Timermgr0Config {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timermgr0Config {}
impl Timermgr0Config {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timermgr0_config::RegisterBlock = 0x3cd0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timermgr0_config::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timermgr0Config {
    type Target = timermgr0_config::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timermgr0Config {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timermgr0Config").finish()
    }
}
#[doc = "TIMERMGR0_CONFIG"]
pub mod timermgr0_config;
#[doc = "MSRAM_256K0_ECC_AGGR_REGS"]
pub struct Msram256k0EccAggrRegs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k0EccAggrRegs {}
impl Msram256k0EccAggrRegs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k0_ecc_aggr_regs::RegisterBlock = 0x3f00_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k0_ecc_aggr_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k0EccAggrRegs {
    type Target = msram_256k0_ecc_aggr_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k0EccAggrRegs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k0EccAggrRegs").finish()
    }
}
#[doc = "MSRAM_256K0_ECC_AGGR_REGS"]
pub mod msram_256k0_ecc_aggr_regs;
#[doc = "MSRAM_256K1_ECC_AGGR_REGS"]
pub struct Msram256k1EccAggrRegs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k1EccAggrRegs {}
impl Msram256k1EccAggrRegs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k1_ecc_aggr_regs::RegisterBlock = 0x3f00_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k1_ecc_aggr_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k1EccAggrRegs {
    type Target = msram_256k1_ecc_aggr_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k1EccAggrRegs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k1EccAggrRegs").finish()
    }
}
#[doc = "MSRAM_256K1_ECC_AGGR_REGS"]
pub mod msram_256k1_ecc_aggr_regs;
#[doc = "MSRAM_256K2_ECC_AGGR_REGS"]
pub struct Msram256k2EccAggrRegs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k2EccAggrRegs {}
impl Msram256k2EccAggrRegs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k2_ecc_aggr_regs::RegisterBlock = 0x3f00_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k2_ecc_aggr_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k2EccAggrRegs {
    type Target = msram_256k2_ecc_aggr_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k2EccAggrRegs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k2EccAggrRegs").finish()
    }
}
#[doc = "MSRAM_256K2_ECC_AGGR_REGS"]
pub mod msram_256k2_ecc_aggr_regs;
#[doc = "GICSS0_REGS"]
pub struct Gicss0Regs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gicss0Regs {}
impl Gicss0Regs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gicss0_regs::RegisterBlock = 0x3f00_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gicss0_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gicss0Regs {
    type Target = gicss0_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gicss0Regs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gicss0Regs").finish()
    }
}
#[doc = "GICSS0_REGS"]
pub mod gicss0_regs;
#[doc = "DMASS0_ECC_AGGR_0_ECCAGGR"]
pub struct Dmass0EccAggr0Eccaggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0EccAggr0Eccaggr {}
impl Dmass0EccAggr0Eccaggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_ecc_aggr_0_eccaggr::RegisterBlock = 0x3f00_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_ecc_aggr_0_eccaggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0EccAggr0Eccaggr {
    type Target = dmass0_ecc_aggr_0_eccaggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0EccAggr0Eccaggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0EccAggr0Eccaggr").finish()
    }
}
#[doc = "DMASS0_ECC_AGGR_0_ECCAGGR"]
pub mod dmass0_ecc_aggr_0_eccaggr;
#[doc = "MSRAM_256K5_ECC_AGGR_REGS"]
pub struct Msram256k5EccAggrRegs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k5EccAggrRegs {}
impl Msram256k5EccAggrRegs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k5_ecc_aggr_regs::RegisterBlock = 0x3f00_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k5_ecc_aggr_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k5EccAggrRegs {
    type Target = msram_256k5_ecc_aggr_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k5EccAggrRegs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k5EccAggrRegs").finish()
    }
}
#[doc = "MSRAM_256K5_ECC_AGGR_REGS"]
pub mod msram_256k5_ecc_aggr_regs;
#[doc = "MSRAM_256K4_ECC_AGGR_REGS"]
pub struct Msram256k4EccAggrRegs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k4EccAggrRegs {}
impl Msram256k4EccAggrRegs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k4_ecc_aggr_regs::RegisterBlock = 0x3f00_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k4_ecc_aggr_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k4EccAggrRegs {
    type Target = msram_256k4_ecc_aggr_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k4EccAggrRegs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k4EccAggrRegs").finish()
    }
}
#[doc = "MSRAM_256K4_ECC_AGGR_REGS"]
pub mod msram_256k4_ecc_aggr_regs;
#[doc = "MSRAM_256K3_ECC_AGGR_REGS"]
pub struct Msram256k3EccAggrRegs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k3EccAggrRegs {}
impl Msram256k3EccAggrRegs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k3_ecc_aggr_regs::RegisterBlock = 0x3f00_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k3_ecc_aggr_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k3EccAggrRegs {
    type Target = msram_256k3_ecc_aggr_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k3EccAggrRegs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k3EccAggrRegs").finish()
    }
}
#[doc = "MSRAM_256K3_ECC_AGGR_REGS"]
pub mod msram_256k3_ecc_aggr_regs;
#[doc = "PRU_ICSSG0_ECC_AGGR"]
pub struct PruIcssg0EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg0EccAggr {}
impl PruIcssg0EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg0_ecc_aggr::RegisterBlock = 0x3f00_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg0_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg0EccAggr {
    type Target = pru_icssg0_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg0EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg0EccAggr").finish()
    }
}
#[doc = "PRU_ICSSG0_ECC_AGGR"]
pub mod pru_icssg0_ecc_aggr;
#[doc = "PRU_ICSSG1_ECC_AGGR"]
pub struct PruIcssg1EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PruIcssg1EccAggr {}
impl PruIcssg1EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pru_icssg1_ecc_aggr::RegisterBlock = 0x3f00_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pru_icssg1_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PruIcssg1EccAggr {
    type Target = pru_icssg1_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PruIcssg1EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PruIcssg1EccAggr").finish()
    }
}
#[doc = "PRU_ICSSG1_ECC_AGGR"]
pub mod pru_icssg1_ecc_aggr;
#[doc = "ECC_AGGR0_ECC_AGGR"]
pub struct EccAggr0EccAggr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EccAggr0EccAggr {}
impl EccAggr0EccAggr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ecc_aggr0_ecc_aggr::RegisterBlock = 0x3f00_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ecc_aggr0_ecc_aggr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for EccAggr0EccAggr {
    type Target = ecc_aggr0_ecc_aggr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EccAggr0EccAggr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EccAggr0EccAggr").finish()
    }
}
#[doc = "ECC_AGGR0_ECC_AGGR"]
pub mod ecc_aggr0_ecc_aggr;
#[doc = "MSRAM_256K6_ECC_AGGR_REGS"]
pub struct Msram256k6EccAggrRegs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k6EccAggrRegs {}
impl Msram256k6EccAggrRegs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k6_ecc_aggr_regs::RegisterBlock = 0x3f01_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k6_ecc_aggr_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k6EccAggrRegs {
    type Target = msram_256k6_ecc_aggr_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k6EccAggrRegs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k6EccAggrRegs").finish()
    }
}
#[doc = "MSRAM_256K6_ECC_AGGR_REGS"]
pub mod msram_256k6_ecc_aggr_regs;
#[doc = "MSRAM_256K7_ECC_AGGR_REGS"]
pub struct Msram256k7EccAggrRegs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k7EccAggrRegs {}
impl Msram256k7EccAggrRegs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k7_ecc_aggr_regs::RegisterBlock = 0x3f01_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k7_ecc_aggr_regs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k7EccAggrRegs {
    type Target = msram_256k7_ecc_aggr_regs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k7EccAggrRegs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k7EccAggrRegs").finish()
    }
}
#[doc = "MSRAM_256K7_ECC_AGGR_REGS"]
pub mod msram_256k7_ecc_aggr_regs;
#[doc = "ROM0"]
pub struct Rom0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rom0 {}
impl Rom0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rom0::RegisterBlock = 0x4180_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rom0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rom0 {
    type Target = rom0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rom0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rom0").finish()
    }
}
#[doc = "ROM0"]
pub mod rom0;
#[doc = "CTRL_MMR0_CFG0"]
pub struct CtrlMmr0Cfg0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CtrlMmr0Cfg0 {}
impl CtrlMmr0Cfg0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ctrl_mmr0_cfg0::RegisterBlock = 0x4300_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ctrl_mmr0_cfg0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CtrlMmr0Cfg0 {
    type Target = ctrl_mmr0_cfg0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CtrlMmr0Cfg0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CtrlMmr0Cfg0").finish()
    }
}
#[doc = "CTRL_MMR0_CFG0"]
pub mod ctrl_mmr0_cfg0;
#[doc = "MSRAM_256K7_RAM"]
pub struct Msram256k7Ram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k7Ram {}
impl Msram256k7Ram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k7_ram::RegisterBlock = 0x4406_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k7_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k7Ram {
    type Target = msram_256k7_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k7Ram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k7Ram").finish()
    }
}
#[doc = "MSRAM_256K6_RAM"]
pub mod msram_256k6_ram;
#[doc = "CBASS0_FW"]
pub struct Cbass0Fw {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cbass0Fw {}
impl Cbass0Fw {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass0_fw::RegisterBlock = 0x4500_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass0_fw::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cbass0Fw {
    type Target = cbass0_fw::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cbass0Fw {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cbass0Fw").finish()
    }
}
#[doc = "CBASS0_FW"]
pub mod cbass0_fw;
#[doc = "CBASS_INFRA1_FW"]
pub struct CbassInfra1Fw {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CbassInfra1Fw {}
impl CbassInfra1Fw {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass_infra1_fw::RegisterBlock = 0x4500_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass_infra1_fw::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CbassInfra1Fw {
    type Target = cbass_infra1_fw::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CbassInfra1Fw {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CbassInfra1Fw").finish()
    }
}
#[doc = "CBASS_INFRA1_FW"]
pub mod cbass_infra1_fw;
#[doc = "CBASS_INFRA1_ISC"]
pub struct CbassInfra1Isc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CbassInfra1Isc {}
impl CbassInfra1Isc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass_infra1_isc::RegisterBlock = 0x4582_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass_infra1_isc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CbassInfra1Isc {
    type Target = cbass_infra1_isc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CbassInfra1Isc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CbassInfra1Isc").finish()
    }
}
#[doc = "CBASS_INFRA1_ISC"]
pub mod cbass_infra1_isc;
#[doc = "MCU_CBASS0_ISC"]
pub struct McuCbass0Isc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuCbass0Isc {}
impl McuCbass0Isc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_cbass0_isc::RegisterBlock = 0x4583_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_cbass0_isc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuCbass0Isc {
    type Target = mcu_cbass0_isc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuCbass0Isc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuCbass0Isc").finish()
    }
}
#[doc = "MCU_CBASS0_ISC"]
pub mod mcu_cbass0_isc;
#[doc = "DMASS0_RINGACC_0_RINGACC_ISC"]
pub struct Dmass0Ringacc0RingaccIsc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Ringacc0RingaccIsc {}
impl Dmass0Ringacc0RingaccIsc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_ringacc_0_ringacc_isc::RegisterBlock = 0x4584_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_ringacc_0_ringacc_isc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Ringacc0RingaccIsc {
    type Target = dmass0_ringacc_0_ringacc_isc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Ringacc0RingaccIsc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Ringacc0RingaccIsc").finish()
    }
}
#[doc = "DMASS0_RINGACC_0_RINGACC_ISC"]
pub mod dmass0_ringacc_0_ringacc_isc;
#[doc = "CBASS0_ISC"]
pub struct Cbass0Isc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cbass0Isc {}
impl Cbass0Isc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass0_isc::RegisterBlock = 0x4588_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass0_isc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cbass0Isc {
    type Target = cbass0_isc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cbass0Isc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cbass0Isc").finish()
    }
}
#[doc = "CBASS0_ISC"]
pub mod cbass0_isc;
#[doc = "CBASS_INFRA1_GLB"]
pub struct CbassInfra1Glb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CbassInfra1Glb {}
impl CbassInfra1Glb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass_infra1_glb::RegisterBlock = 0x45b0_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass_infra1_glb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CbassInfra1Glb {
    type Target = cbass_infra1_glb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CbassInfra1Glb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CbassInfra1Glb").finish()
    }
}
#[doc = "CBASS_INFRA1_GLB"]
pub mod cbass_infra1_glb;
#[doc = "MCU_CBASS0_GLB"]
pub struct McuCbass0Glb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuCbass0Glb {}
impl McuCbass0Glb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_cbass0_glb::RegisterBlock = 0x45b0_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_cbass0_glb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuCbass0Glb {
    type Target = mcu_cbass0_glb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuCbass0Glb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuCbass0Glb").finish()
    }
}
#[doc = "MCU_CBASS0_GLB"]
pub mod mcu_cbass0_glb;
#[doc = "CBASS0_GLB"]
pub struct Cbass0Glb {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cbass0Glb {}
impl Cbass0Glb {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass0_glb::RegisterBlock = 0x45b0_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass0_glb::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cbass0Glb {
    type Target = cbass0_glb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cbass0Glb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cbass0Glb").finish()
    }
}
#[doc = "CBASS0_GLB"]
pub mod cbass0_glb;
#[doc = "CBASS_INFRA1_QOS"]
pub struct CbassInfra1Qos {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CbassInfra1Qos {}
impl CbassInfra1Qos {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass_infra1_qos::RegisterBlock = 0x45d2_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass_infra1_qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CbassInfra1Qos {
    type Target = cbass_infra1_qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CbassInfra1Qos {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CbassInfra1Qos").finish()
    }
}
#[doc = "CBASS_INFRA1_QOS"]
pub mod cbass_infra1_qos;
#[doc = "MCU_CBASS0_QOS"]
pub struct McuCbass0Qos {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for McuCbass0Qos {}
impl McuCbass0Qos {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mcu_cbass0_qos::RegisterBlock = 0x45d3_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mcu_cbass0_qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for McuCbass0Qos {
    type Target = mcu_cbass0_qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for McuCbass0Qos {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("McuCbass0Qos").finish()
    }
}
#[doc = "MCU_CBASS0_QOS"]
pub mod mcu_cbass0_qos;
#[doc = "CBASS0_QOS"]
pub struct Cbass0Qos {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cbass0Qos {}
impl Cbass0Qos {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cbass0_qos::RegisterBlock = 0x45d8_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cbass0_qos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cbass0Qos {
    type Target = cbass0_qos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cbass0Qos {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cbass0Qos").finish()
    }
}
#[doc = "CBASS0_QOS"]
pub mod cbass0_qos;
#[doc = "DMASS0_INTAGGR_0_INTAGGR_INTR"]
pub struct Dmass0Intaggr0IntaggrIntr {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Intaggr0IntaggrIntr {}
impl Dmass0Intaggr0IntaggrIntr {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_intaggr_0_intaggr_intr::RegisterBlock = 0x4800_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_intaggr_0_intaggr_intr::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Intaggr0IntaggrIntr {
    type Target = dmass0_intaggr_0_intaggr_intr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Intaggr0IntaggrIntr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Intaggr0IntaggrIntr").finish()
    }
}
#[doc = "DMASS0_INTAGGR_0_INTAGGR_INTR"]
pub mod dmass0_intaggr_0_intaggr_intr;
#[doc = "DMASS0_INTAGGR_0_INTAGGR_IMAP"]
pub struct Dmass0Intaggr0IntaggrImap {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Intaggr0IntaggrImap {}
impl Dmass0Intaggr0IntaggrImap {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_intaggr_0_intaggr_imap::RegisterBlock = 0x4810_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_intaggr_0_intaggr_imap::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Intaggr0IntaggrImap {
    type Target = dmass0_intaggr_0_intaggr_imap::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Intaggr0IntaggrImap {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Intaggr0IntaggrImap").finish()
    }
}
#[doc = "DMASS0_INTAGGR_0_INTAGGR_IMAP"]
pub mod dmass0_intaggr_0_intaggr_imap;
#[doc = "DMASS0_INTAGGR_0_INTAGGR_CFG"]
pub struct Dmass0Intaggr0IntaggrCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Intaggr0IntaggrCfg {}
impl Dmass0Intaggr0IntaggrCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_intaggr_0_intaggr_cfg::RegisterBlock = 0x4811_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_intaggr_0_intaggr_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Intaggr0IntaggrCfg {
    type Target = dmass0_intaggr_0_intaggr_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Intaggr0IntaggrCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Intaggr0IntaggrCfg").finish()
    }
}
#[doc = "DMASS0_INTAGGR_0_INTAGGR_CFG"]
pub mod dmass0_intaggr_0_intaggr_cfg;
#[doc = "DMASS0_INTAGGR_0_INTAGGR_L2G"]
pub struct Dmass0Intaggr0IntaggrL2g {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Intaggr0IntaggrL2g {}
impl Dmass0Intaggr0IntaggrL2g {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_intaggr_0_intaggr_l2g::RegisterBlock = 0x4812_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_intaggr_0_intaggr_l2g::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Intaggr0IntaggrL2g {
    type Target = dmass0_intaggr_0_intaggr_l2g::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Intaggr0IntaggrL2g {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Intaggr0IntaggrL2g").finish()
    }
}
#[doc = "DMASS0_INTAGGR_0_INTAGGR_L2G"]
pub mod dmass0_intaggr_0_intaggr_l2g;
#[doc = "DMASS0_PSILCFG_0_PSILCFG_PROXY"]
pub struct Dmass0Psilcfg0PsilcfgProxy {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Psilcfg0PsilcfgProxy {}
impl Dmass0Psilcfg0PsilcfgProxy {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_psilcfg_0_psilcfg_proxy::RegisterBlock = 0x4813_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_psilcfg_0_psilcfg_proxy::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Psilcfg0PsilcfgProxy {
    type Target = dmass0_psilcfg_0_psilcfg_proxy::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Psilcfg0PsilcfgProxy {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Psilcfg0PsilcfgProxy").finish()
    }
}
#[doc = "DMASS0_PSILCFG_0_PSILCFG_PROXY"]
pub mod dmass0_psilcfg_0_psilcfg_proxy;
#[doc = "DMASS0_PSILSS_0_PSILSS_MMRS"]
pub struct Dmass0Psilss0PsilssMmrs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Psilss0PsilssMmrs {}
impl Dmass0Psilss0PsilssMmrs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_psilss_0_psilss_mmrs::RegisterBlock = 0x4814_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_psilss_0_psilss_mmrs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Psilss0PsilssMmrs {
    type Target = dmass0_psilss_0_psilss_mmrs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Psilss0PsilssMmrs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Psilss0PsilssMmrs").finish()
    }
}
#[doc = "DMASS0_PSILSS_0_PSILSS_MMRS"]
pub mod dmass0_psilss_0_psilss_mmrs;
#[doc = "DMASS0_INTAGGR_0_INTAGGR_UNMAP"]
pub struct Dmass0Intaggr0IntaggrUnmap {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Intaggr0IntaggrUnmap {}
impl Dmass0Intaggr0IntaggrUnmap {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_intaggr_0_intaggr_unmap::RegisterBlock = 0x4818_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_intaggr_0_intaggr_unmap::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Intaggr0IntaggrUnmap {
    type Target = dmass0_intaggr_0_intaggr_unmap::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Intaggr0IntaggrUnmap {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Intaggr0IntaggrUnmap").finish()
    }
}
#[doc = "DMASS0_INTAGGR_0_INTAGGR_UNMAP"]
pub mod dmass0_intaggr_0_intaggr_unmap;
#[doc = "DMASS0_INTAGGR_0_INTAGGR_MCAST"]
pub struct Dmass0Intaggr0IntaggrMcast {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Intaggr0IntaggrMcast {}
impl Dmass0Intaggr0IntaggrMcast {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_intaggr_0_intaggr_mcast::RegisterBlock = 0x4821_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_intaggr_0_intaggr_mcast::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Intaggr0IntaggrMcast {
    type Target = dmass0_intaggr_0_intaggr_mcast::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Intaggr0IntaggrMcast {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Intaggr0IntaggrMcast").finish()
    }
}
#[doc = "DMASS0_INTAGGR_0_INTAGGR_MCAST"]
pub mod dmass0_intaggr_0_intaggr_mcast;
#[doc = "DMASS0_INTAGGR_0_INTAGGR_GCNTCFG"]
pub struct Dmass0Intaggr0IntaggrGcntcfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Intaggr0IntaggrGcntcfg {}
impl Dmass0Intaggr0IntaggrGcntcfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_intaggr_0_intaggr_gcntcfg::RegisterBlock = 0x4822_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_intaggr_0_intaggr_gcntcfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Intaggr0IntaggrGcntcfg {
    type Target = dmass0_intaggr_0_intaggr_gcntcfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Intaggr0IntaggrGcntcfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Intaggr0IntaggrGcntcfg").finish()
    }
}
#[doc = "DMASS0_INTAGGR_0_INTAGGR_GCNTCFG"]
pub mod dmass0_intaggr_0_intaggr_gcntcfg;
#[doc = "DMASS0_PSILSS_0_ETLSW_MMRS"]
pub struct Dmass0Psilss0EtlswMmrs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Psilss0EtlswMmrs {}
impl Dmass0Psilss0EtlswMmrs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_psilss_0_etlsw_mmrs::RegisterBlock = 0x4823_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_psilss_0_etlsw_mmrs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Psilss0EtlswMmrs {
    type Target = dmass0_psilss_0_etlsw_mmrs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Psilss0EtlswMmrs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Psilss0EtlswMmrs").finish()
    }
}
#[doc = "DMASS0_PSILSS_0_ETLSW_MMRS"]
pub mod dmass0_psilss_0_etlsw_mmrs;
#[doc = "DMASS0_RINGACC_0_RINGACC_GCFG"]
pub struct Dmass0Ringacc0RingaccGcfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Ringacc0RingaccGcfg {}
impl Dmass0Ringacc0RingaccGcfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_ringacc_0_ringacc_gcfg::RegisterBlock = 0x4824_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_ringacc_0_ringacc_gcfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Ringacc0RingaccGcfg {
    type Target = dmass0_ringacc_0_ringacc_gcfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Ringacc0RingaccGcfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Ringacc0RingaccGcfg").finish()
    }
}
#[doc = "DMASS0_RINGACC_0_RINGACC_GCFG"]
pub mod dmass0_ringacc_0_ringacc_gcfg;
#[doc = "DMASS0_BCDMA_0_BCDMA_CRED"]
pub struct Dmass0Bcdma0BcdmaCred {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Bcdma0BcdmaCred {}
impl Dmass0Bcdma0BcdmaCred {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_bcdma_0_bcdma_cred::RegisterBlock = 0x4840_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_bcdma_0_bcdma_cred::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Bcdma0BcdmaCred {
    type Target = dmass0_bcdma_0_bcdma_cred::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Bcdma0BcdmaCred {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Bcdma0BcdmaCred").finish()
    }
}
#[doc = "DMASS0_BCDMA_0_BCDMA_CRED"]
pub mod dmass0_bcdma_0_bcdma_cred;
#[doc = "DMASS0_PKTDMA_0_PKTDMA_CRED"]
pub struct Dmass0Pktdma0PktdmaCred {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Pktdma0PktdmaCred {}
impl Dmass0Pktdma0PktdmaCred {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_pktdma_0_pktdma_cred::RegisterBlock = 0x4841_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_pktdma_0_pktdma_cred::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Pktdma0PktdmaCred {
    type Target = dmass0_pktdma_0_pktdma_cred::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Pktdma0PktdmaCred {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Pktdma0PktdmaCred").finish()
    }
}
#[doc = "DMASS0_PKTDMA_0_PKTDMA_CRED"]
pub mod dmass0_pktdma_0_pktdma_cred;
#[doc = "DMASS0_BCDMA_0_BCDMA_BCHAN"]
pub struct Dmass0Bcdma0BcdmaBchan {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Bcdma0BcdmaBchan {}
impl Dmass0Bcdma0BcdmaBchan {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_bcdma_0_bcdma_bchan::RegisterBlock = 0x4842_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_bcdma_0_bcdma_bchan::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Bcdma0BcdmaBchan {
    type Target = dmass0_bcdma_0_bcdma_bchan::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Bcdma0BcdmaBchan {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Bcdma0BcdmaBchan").finish()
    }
}
#[doc = "DMASS0_BCDMA_0_BCDMA_BCHAN"]
pub mod dmass0_bcdma_0_bcdma_bchan;
#[doc = "DMASS0_PKTDMA_0_PKTDMA_RFLOW"]
pub struct Dmass0Pktdma0PktdmaRflow {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Pktdma0PktdmaRflow {}
impl Dmass0Pktdma0PktdmaRflow {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_pktdma_0_pktdma_rflow::RegisterBlock = 0x4843_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_pktdma_0_pktdma_rflow::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Pktdma0PktdmaRflow {
    type Target = dmass0_pktdma_0_pktdma_rflow::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Pktdma0PktdmaRflow {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Pktdma0PktdmaRflow").finish()
    }
}
#[doc = "DMASS0_PKTDMA_0_PKTDMA_RFLOW"]
pub mod dmass0_pktdma_0_pktdma_rflow;
#[doc = "DMASS0_PKTDMA_0_PKTDMA_TCHAN"]
pub struct Dmass0Pktdma0PktdmaTchan {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Pktdma0PktdmaTchan {}
impl Dmass0Pktdma0PktdmaTchan {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_pktdma_0_pktdma_tchan::RegisterBlock = 0x484a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_pktdma_0_pktdma_tchan::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Pktdma0PktdmaTchan {
    type Target = dmass0_pktdma_0_pktdma_tchan::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Pktdma0PktdmaTchan {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Pktdma0PktdmaTchan").finish()
    }
}
#[doc = "DMASS0_PKTDMA_0_PKTDMA_TCHAN"]
pub mod dmass0_pktdma_0_pktdma_tchan;
#[doc = "DMASS0_BCDMA_0_BCDMA_TCHAN"]
pub struct Dmass0Bcdma0BcdmaTchan {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Bcdma0BcdmaTchan {}
impl Dmass0Bcdma0BcdmaTchan {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_bcdma_0_bcdma_tchan::RegisterBlock = 0x484a_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_bcdma_0_bcdma_tchan::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Bcdma0BcdmaTchan {
    type Target = dmass0_bcdma_0_bcdma_tchan::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Bcdma0BcdmaTchan {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Bcdma0BcdmaTchan").finish()
    }
}
#[doc = "DMASS0_BCDMA_0_BCDMA_TCHAN"]
pub mod dmass0_bcdma_0_bcdma_tchan;
#[doc = "DMASS0_PKTDMA_0_PKTDMA_RCHAN"]
pub struct Dmass0Pktdma0PktdmaRchan {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Pktdma0PktdmaRchan {}
impl Dmass0Pktdma0PktdmaRchan {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_pktdma_0_pktdma_rchan::RegisterBlock = 0x484c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_pktdma_0_pktdma_rchan::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Pktdma0PktdmaRchan {
    type Target = dmass0_pktdma_0_pktdma_rchan::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Pktdma0PktdmaRchan {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Pktdma0PktdmaRchan").finish()
    }
}
#[doc = "DMASS0_PKTDMA_0_PKTDMA_RCHAN"]
pub mod dmass0_pktdma_0_pktdma_rchan;
#[doc = "DMASS0_BCDMA_0_BCDMA_RCHAN"]
pub struct Dmass0Bcdma0BcdmaRchan {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Bcdma0BcdmaRchan {}
impl Dmass0Bcdma0BcdmaRchan {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_bcdma_0_bcdma_rchan::RegisterBlock = 0x484c_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_bcdma_0_bcdma_rchan::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Bcdma0BcdmaRchan {
    type Target = dmass0_bcdma_0_bcdma_rchan::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Bcdma0BcdmaRchan {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Bcdma0BcdmaRchan").finish()
    }
}
#[doc = "DMASS0_BCDMA_0_BCDMA_RCHAN"]
pub mod dmass0_bcdma_0_bcdma_rchan;
#[doc = "DMASS0_PKTDMA_0_PKTDMA_GCFG"]
pub struct Dmass0Pktdma0PktdmaGcfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Pktdma0PktdmaGcfg {}
impl Dmass0Pktdma0PktdmaGcfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_pktdma_0_pktdma_gcfg::RegisterBlock = 0x485c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_pktdma_0_pktdma_gcfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Pktdma0PktdmaGcfg {
    type Target = dmass0_pktdma_0_pktdma_gcfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Pktdma0PktdmaGcfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Pktdma0PktdmaGcfg").finish()
    }
}
#[doc = "DMASS0_PKTDMA_0_PKTDMA_GCFG"]
pub mod dmass0_pktdma_0_pktdma_gcfg;
#[doc = "DMASS0_BCDMA_0_BCDMA_GCFG"]
pub struct Dmass0Bcdma0BcdmaGcfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Bcdma0BcdmaGcfg {}
impl Dmass0Bcdma0BcdmaGcfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_bcdma_0_bcdma_gcfg::RegisterBlock = 0x485c_0100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_bcdma_0_bcdma_gcfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Bcdma0BcdmaGcfg {
    type Target = dmass0_bcdma_0_bcdma_gcfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Bcdma0BcdmaGcfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Bcdma0BcdmaGcfg").finish()
    }
}
#[doc = "DMASS0_BCDMA_0_BCDMA_GCFG"]
pub mod dmass0_bcdma_0_bcdma_gcfg;
#[doc = "DMASS0_PKTDMA_0_PKTDMA_RING"]
pub struct Dmass0Pktdma0PktdmaRing {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Pktdma0PktdmaRing {}
impl Dmass0Pktdma0PktdmaRing {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_pktdma_0_pktdma_ring::RegisterBlock = 0x485e_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_pktdma_0_pktdma_ring::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Pktdma0PktdmaRing {
    type Target = dmass0_pktdma_0_pktdma_ring::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Pktdma0PktdmaRing {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Pktdma0PktdmaRing").finish()
    }
}
#[doc = "DMASS0_PKTDMA_0_PKTDMA_RING"]
pub mod dmass0_pktdma_0_pktdma_ring;
#[doc = "DMASS0_BCDMA_0_BCDMA_RING"]
pub struct Dmass0Bcdma0BcdmaRing {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Bcdma0BcdmaRing {}
impl Dmass0Bcdma0BcdmaRing {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_bcdma_0_bcdma_ring::RegisterBlock = 0x4860_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_bcdma_0_bcdma_ring::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Bcdma0BcdmaRing {
    type Target = dmass0_bcdma_0_bcdma_ring::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Bcdma0BcdmaRing {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Bcdma0BcdmaRing").finish()
    }
}
#[doc = "DMASS0_BCDMA_0_BCDMA_RING"]
pub mod dmass0_bcdma_0_bcdma_ring;
#[doc = "DMASS0_RINGACC_0_RINGACC_RT"]
pub struct Dmass0Ringacc0RingaccRt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Ringacc0RingaccRt {}
impl Dmass0Ringacc0RingaccRt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_ringacc_0_ringacc_rt::RegisterBlock = 0x4900_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_ringacc_0_ringacc_rt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Ringacc0RingaccRt {
    type Target = dmass0_ringacc_0_ringacc_rt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Ringacc0RingaccRt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Ringacc0RingaccRt").finish()
    }
}
#[doc = "DMASS0_RINGACC_0_RINGACC_RT"]
pub mod dmass0_ringacc_0_ringacc_rt;
#[doc = "DMASS0_RINGACC_0_RINGACC_CFG"]
pub struct Dmass0Ringacc0RingaccCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Ringacc0RingaccCfg {}
impl Dmass0Ringacc0RingaccCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_ringacc_0_ringacc_cfg::RegisterBlock = 0x4980_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_ringacc_0_ringacc_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Ringacc0RingaccCfg {
    type Target = dmass0_ringacc_0_ringacc_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Ringacc0RingaccCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Ringacc0RingaccCfg").finish()
    }
}
#[doc = "DMASS0_RINGACC_0_RINGACC_CFG"]
pub mod dmass0_ringacc_0_ringacc_cfg;
#[doc = "DMASS0_INTAGGR_0_INTAGGR_GCNTRTI"]
pub struct Dmass0Intaggr0IntaggrGcntrti {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Intaggr0IntaggrGcntrti {}
impl Dmass0Intaggr0IntaggrGcntrti {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_intaggr_0_intaggr_gcntrti::RegisterBlock = 0x4a00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_intaggr_0_intaggr_gcntrti::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Intaggr0IntaggrGcntrti {
    type Target = dmass0_intaggr_0_intaggr_gcntrti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Intaggr0IntaggrGcntrti {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Intaggr0IntaggrGcntrti").finish()
    }
}
#[doc = "DMASS0_INTAGGR_0_INTAGGR_GCNTRTI"]
pub mod dmass0_intaggr_0_intaggr_gcntrti;
#[doc = "DMASS0_PKTDMA_0_PKTDMA_RCHANRT"]
pub struct Dmass0Pktdma0PktdmaRchanrt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Pktdma0PktdmaRchanrt {}
impl Dmass0Pktdma0PktdmaRchanrt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_pktdma_0_pktdma_rchanrt::RegisterBlock = 0x4a80_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_pktdma_0_pktdma_rchanrt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Pktdma0PktdmaRchanrt {
    type Target = dmass0_pktdma_0_pktdma_rchanrt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Pktdma0PktdmaRchanrt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Pktdma0PktdmaRchanrt").finish()
    }
}
#[doc = "DMASS0_PKTDMA_0_PKTDMA_RCHANRT"]
pub mod dmass0_pktdma_0_pktdma_rchanrt;
#[doc = "DMASS0_BCDMA_0_BCDMA_RCHANRT"]
pub struct Dmass0Bcdma0BcdmaRchanrt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Bcdma0BcdmaRchanrt {}
impl Dmass0Bcdma0BcdmaRchanrt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_bcdma_0_bcdma_rchanrt::RegisterBlock = 0x4a82_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_bcdma_0_bcdma_rchanrt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Bcdma0BcdmaRchanrt {
    type Target = dmass0_bcdma_0_bcdma_rchanrt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Bcdma0BcdmaRchanrt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Bcdma0BcdmaRchanrt").finish()
    }
}
#[doc = "DMASS0_BCDMA_0_BCDMA_RCHANRT"]
pub mod dmass0_bcdma_0_bcdma_rchanrt;
#[doc = "DMASS0_PKTDMA_0_PKTDMA_TCHANRT"]
pub struct Dmass0Pktdma0PktdmaTchanrt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Pktdma0PktdmaTchanrt {}
impl Dmass0Pktdma0PktdmaTchanrt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_pktdma_0_pktdma_tchanrt::RegisterBlock = 0x4aa0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_pktdma_0_pktdma_tchanrt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Pktdma0PktdmaTchanrt {
    type Target = dmass0_pktdma_0_pktdma_tchanrt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Pktdma0PktdmaTchanrt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Pktdma0PktdmaTchanrt").finish()
    }
}
#[doc = "DMASS0_PKTDMA_0_PKTDMA_TCHANRT"]
pub mod dmass0_pktdma_0_pktdma_tchanrt;
#[doc = "DMASS0_BCDMA_0_BCDMA_TCHANRT"]
pub struct Dmass0Bcdma0BcdmaTchanrt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Bcdma0BcdmaTchanrt {}
impl Dmass0Bcdma0BcdmaTchanrt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_bcdma_0_bcdma_tchanrt::RegisterBlock = 0x4aa4_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_bcdma_0_bcdma_tchanrt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Bcdma0BcdmaTchanrt {
    type Target = dmass0_bcdma_0_bcdma_tchanrt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Bcdma0BcdmaTchanrt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Bcdma0BcdmaTchanrt").finish()
    }
}
#[doc = "DMASS0_BCDMA_0_BCDMA_TCHANRT"]
pub mod dmass0_bcdma_0_bcdma_tchanrt;
#[doc = "DMASS0_PKTDMA_0_PKTDMA_RINGRT"]
pub struct Dmass0Pktdma0PktdmaRingrt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Pktdma0PktdmaRingrt {}
impl Dmass0Pktdma0PktdmaRingrt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_pktdma_0_pktdma_ringrt::RegisterBlock = 0x4b80_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_pktdma_0_pktdma_ringrt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Pktdma0PktdmaRingrt {
    type Target = dmass0_pktdma_0_pktdma_ringrt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Pktdma0PktdmaRingrt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Pktdma0PktdmaRingrt").finish()
    }
}
#[doc = "DMASS0_PKTDMA_0_PKTDMA_RINGRT"]
pub mod dmass0_pktdma_0_pktdma_ringrt;
#[doc = "DMASS0_BCDMA_0_BCDMA_RINGRT"]
pub struct Dmass0Bcdma0BcdmaRingrt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Bcdma0BcdmaRingrt {}
impl Dmass0Bcdma0BcdmaRingrt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_bcdma_0_bcdma_ringrt::RegisterBlock = 0x4bc0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_bcdma_0_bcdma_ringrt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Bcdma0BcdmaRingrt {
    type Target = dmass0_bcdma_0_bcdma_ringrt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Bcdma0BcdmaRingrt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Bcdma0BcdmaRingrt").finish()
    }
}
#[doc = "DMASS0_BCDMA_0_BCDMA_RINGRT"]
pub mod dmass0_bcdma_0_bcdma_ringrt;
#[doc = "DMASS0_BCDMA_0_BCDMA_BCHANRT"]
pub struct Dmass0Bcdma0BcdmaBchanrt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Bcdma0BcdmaBchanrt {}
impl Dmass0Bcdma0BcdmaBchanrt {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_bcdma_0_bcdma_bchanrt::RegisterBlock = 0x4c00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_bcdma_0_bcdma_bchanrt::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Bcdma0BcdmaBchanrt {
    type Target = dmass0_bcdma_0_bcdma_bchanrt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Bcdma0BcdmaBchanrt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Bcdma0BcdmaBchanrt").finish()
    }
}
#[doc = "DMASS0_BCDMA_0_BCDMA_BCHANRT"]
pub mod dmass0_bcdma_0_bcdma_bchanrt;
#[doc = "DMASS0_RINGACC_0_RINGACC_SRC_FIFOS"]
pub struct Dmass0Ringacc0RingaccSrcFifos {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmass0Ringacc0RingaccSrcFifos {}
impl Dmass0Ringacc0RingaccSrcFifos {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmass0_ringacc_0_ringacc_src_fifos::RegisterBlock =
        0x4e00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmass0_ringacc_0_ringacc_src_fifos::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmass0Ringacc0RingaccSrcFifos {
    type Target = dmass0_ringacc_0_ringacc_src_fifos::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmass0Ringacc0RingaccSrcFifos {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmass0Ringacc0RingaccSrcFifos").finish()
    }
}
#[doc = "DMASS0_RINGACC_0_RINGACC_SRC_FIFOS"]
pub mod dmass0_ringacc_0_ringacc_src_fifos;
#[doc = "FSS0_FSAS_0_DAT_REG1"]
pub struct Fss0Fsas0DatReg1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fss0Fsas0DatReg1 {}
impl Fss0Fsas0DatReg1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fss0_fsas_0_dat_reg1::RegisterBlock = 0x6000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fss0_fsas_0_dat_reg1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fss0Fsas0DatReg1 {
    type Target = fss0_fsas_0_dat_reg1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fss0Fsas0DatReg1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fss0Fsas0DatReg1").finish()
    }
}
#[doc = "FSS0_FSAS_0_DAT_REG1"]
pub mod fss0_fsas_0_dat_reg1;
#[doc = "MSRAM_256K0_RAM"]
pub struct Msram256k0Ram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k0Ram {}
impl Msram256k0Ram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k0_ram::RegisterBlock = 0x7000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k0_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k0Ram {
    type Target = msram_256k0_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k0Ram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k0Ram").finish()
    }
}
#[doc = "MSRAM_256K0_RAM"]
pub mod msram_256k0_ram;
#[doc = "MSRAM_256K1_RAM"]
pub struct Msram256k1Ram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k1Ram {}
impl Msram256k1Ram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k1_ram::RegisterBlock = 0x7004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k1_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k1Ram {
    type Target = msram_256k1_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k1Ram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k1Ram").finish()
    }
}
#[doc = "MSRAM_256K1_RAM"]
pub mod msram_256k1_ram;
#[doc = "MSRAM_256K2_RAM"]
pub struct Msram256k2Ram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k2Ram {}
impl Msram256k2Ram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k2_ram::RegisterBlock = 0x7008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k2_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k2Ram {
    type Target = msram_256k2_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k2Ram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k2Ram").finish()
    }
}
#[doc = "MSRAM_256K2_RAM"]
pub mod msram_256k2_ram;
#[doc = "MSRAM_256K3_RAM"]
pub struct Msram256k3Ram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k3Ram {}
impl Msram256k3Ram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k3_ram::RegisterBlock = 0x700c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k3_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k3Ram {
    type Target = msram_256k3_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k3Ram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k3Ram").finish()
    }
}
#[doc = "MSRAM_256K3_RAM"]
pub mod msram_256k3_ram;
#[doc = "MSRAM_256K4_RAM"]
pub struct Msram256k4Ram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k4Ram {}
impl Msram256k4Ram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k4_ram::RegisterBlock = 0x7010_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k4_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k4Ram {
    type Target = msram_256k4_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k4Ram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k4Ram").finish()
    }
}
#[doc = "MSRAM_256K4_RAM"]
pub mod msram_256k4_ram;
#[doc = "MSRAM_256K5_RAM"]
pub struct Msram256k5Ram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k5Ram {}
impl Msram256k5Ram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k5_ram::RegisterBlock = 0x7014_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k5_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k5Ram {
    type Target = msram_256k5_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k5Ram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k5Ram").finish()
    }
}
#[doc = "MSRAM_256K5_RAM"]
pub mod msram_256k5_ram;
#[doc = "MSRAM_256K6_RAM"]
pub struct Msram256k6Ram {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Msram256k6Ram {}
impl Msram256k6Ram {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const msram_256k6_ram::RegisterBlock = 0x7018_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const msram_256k6_ram::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Msram256k6Ram {
    type Target = msram_256k6_ram::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Msram256k6Ram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Msram256k6Ram").finish()
    }
}
#[doc = "MSRAM_256K7_RAM"]
pub mod msram_256k7_ram;
#[doc = "FSS0_FSAS_0_DAT_REG0"]
pub struct Fss0Fsas0DatReg0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fss0Fsas0DatReg0 {}
impl Fss0Fsas0DatReg0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fss0_fsas_0_dat_reg0::RegisterBlock = 0x0004_0000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fss0_fsas_0_dat_reg0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fss0Fsas0DatReg0 {
    type Target = fss0_fsas_0_dat_reg0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fss0Fsas0DatReg0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fss0Fsas0DatReg0").finish()
    }
}
#[doc = "FSS0_FSAS_0_DAT_REG0"]
pub mod fss0_fsas_0_dat_reg0;
#[doc = "FSS0_FSAS_0_DAT_REG3"]
pub struct Fss0Fsas0DatReg3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fss0Fsas0DatReg3 {}
impl Fss0Fsas0DatReg3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fss0_fsas_0_dat_reg3::RegisterBlock = 0x0005_0000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fss0_fsas_0_dat_reg3::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fss0Fsas0DatReg3 {
    type Target = fss0_fsas_0_dat_reg3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fss0Fsas0DatReg3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fss0Fsas0DatReg3").finish()
    }
}
#[doc = "FSS0_FSAS_0_DAT_REG3"]
pub mod fss0_fsas_0_dat_reg3;
#[doc = "A53SS0_SS_ROM"]
pub struct A53ss0SsRom {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0SsRom {}
impl A53ss0SsRom {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_ss_rom::RegisterBlock = 0x0007_3000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_ss_rom::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0SsRom {
    type Target = a53ss0_ss_rom::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0SsRom {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0SsRom").finish()
    }
}
#[doc = "A53SS0_SS_ROM"]
pub mod a53ss0_ss_rom;
#[doc = "A53SS0_CORE0_DBG"]
pub struct A53ss0Core0Dbg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0Core0Dbg {}
impl A53ss0Core0Dbg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_core0_dbg::RegisterBlock = 0x0007_3001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_core0_dbg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0Core0Dbg {
    type Target = a53ss0_core0_dbg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0Core0Dbg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0Core0Dbg").finish()
    }
}
#[doc = "A53SS0_CORE0_DBG"]
pub mod a53ss0_core0_dbg;
#[doc = "A53SS0_CORE0_CTI"]
pub struct A53ss0Core0Cti {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0Core0Cti {}
impl A53ss0Core0Cti {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_core0_cti::RegisterBlock = 0x0007_3002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_core0_cti::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0Core0Cti {
    type Target = a53ss0_core0_cti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0Core0Cti {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0Core0Cti").finish()
    }
}
#[doc = "A53SS0_CORE0_CTI"]
pub mod a53ss0_core0_cti;
#[doc = "A53SS0_CORE0_PMU"]
pub struct A53ss0Core0Pmu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0Core0Pmu {}
impl A53ss0Core0Pmu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_core0_pmu::RegisterBlock = 0x0007_3003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_core0_pmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0Core0Pmu {
    type Target = a53ss0_core0_pmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0Core0Pmu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0Core0Pmu").finish()
    }
}
#[doc = "A53SS0_CORE0_PMU"]
pub mod a53ss0_core0_pmu;
#[doc = "A53SS0_CORE0_ETM"]
pub struct A53ss0Core0Etm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0Core0Etm {}
impl A53ss0Core0Etm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_core0_etm::RegisterBlock = 0x0007_3004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_core0_etm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0Core0Etm {
    type Target = a53ss0_core0_etm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0Core0Etm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0Core0Etm").finish()
    }
}
#[doc = "A53SS0_CORE0_ETM"]
pub mod a53ss0_core0_etm;
#[doc = "A53SS0_CORE1_DBG"]
pub struct A53ss0Core1Dbg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0Core1Dbg {}
impl A53ss0Core1Dbg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_core1_dbg::RegisterBlock = 0x0007_3011_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_core1_dbg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0Core1Dbg {
    type Target = a53ss0_core1_dbg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0Core1Dbg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0Core1Dbg").finish()
    }
}
#[doc = "A53SS0_CORE1_DBG"]
pub mod a53ss0_core1_dbg;
#[doc = "A53SS0_CORE1_PMU"]
pub struct A53ss0Core1Pmu {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0Core1Pmu {}
impl A53ss0Core1Pmu {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_core1_pmu::RegisterBlock = 0x0007_3012_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_core1_pmu::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0Core1Pmu {
    type Target = a53ss0_core1_pmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0Core1Pmu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0Core1Pmu").finish()
    }
}
#[doc = "A53SS0_CORE1_PMU"]
pub mod a53ss0_core1_pmu;
#[doc = "A53SS0_CORE1_ETM"]
pub struct A53ss0Core1Etm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0Core1Etm {}
impl A53ss0Core1Etm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_core1_etm::RegisterBlock = 0x0007_3013_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_core1_etm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0Core1Etm {
    type Target = a53ss0_core1_etm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0Core1Etm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0Core1Etm").finish()
    }
}
#[doc = "A53SS0_CORE1_ETM"]
pub mod a53ss0_core1_etm;
#[doc = "A53SS0_CORE1_CTI"]
pub struct A53ss0Core1Cti {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for A53ss0Core1Cti {}
impl A53ss0Core1Cti {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const a53ss0_core1_cti::RegisterBlock = 0x0007_3014_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const a53ss0_core1_cti::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for A53ss0Core1Cti {
    type Target = a53ss0_core1_cti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for A53ss0Core1Cti {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("A53ss0Core1Cti").finish()
    }
}
#[doc = "A53SS0_CORE1_CTI"]
pub mod a53ss0_core1_cti;
#[doc = "STM0_CXSTM"]
pub struct Stm0Cxstm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stm0Cxstm {}
impl Stm0Cxstm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const stm0_cxstm::RegisterBlock = 0x0007_3d20_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const stm0_cxstm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stm0Cxstm {
    type Target = stm0_cxstm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stm0Cxstm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stm0Cxstm").finish()
    }
}
#[doc = "STM0_CXSTM"]
pub mod stm0_cxstm;
#[doc = "STM0_CTI_CSCTI"]
pub struct Stm0CtiCscti {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Stm0CtiCscti {}
impl Stm0CtiCscti {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const stm0_cti_cscti::RegisterBlock = 0x0007_3d20_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const stm0_cti_cscti::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Stm0CtiCscti {
    type Target = stm0_cti_cscti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Stm0CtiCscti {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Stm0CtiCscti").finish()
    }
}
#[doc = "STM0_CTI_CSCTI"]
pub mod stm0_cti_cscti;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PSRAMECC0_RAM"]
    pub psramecc0_ram: Psramecc0Ram,
    #[doc = "PADCFG_CTRL0_CFG0"]
    pub padcfg_ctrl0_cfg0: PadcfgCtrl0Cfg0,
    #[doc = "CBASS_DBG0_ERR"]
    pub cbass_dbg0_err: CbassDbg0Err,
    #[doc = "CBASS_INFRA1_ERR"]
    pub cbass_infra1_err: CbassInfra1Err,
    #[doc = "CBASS_FW0_ERR"]
    pub cbass_fw0_err: CbassFw0Err,
    #[doc = "PSC0"]
    pub psc0: Psc0,
    #[doc = "ESM0_CFG"]
    pub esm0_cfg: Esm0Cfg,
    #[doc = "GPIO0"]
    pub gpio0: Gpio0,
    #[doc = "GPIO1"]
    pub gpio1: Gpio1,
    #[doc = "PLL0_CFG"]
    pub pll0_cfg: Pll0Cfg,
    #[doc = "PSRAMECC0_ECC_AGGR"]
    pub psramecc0_ecc_aggr: Psramecc0EccAggr,
    #[doc = "ECC_AGGR1_ECC_AGGR"]
    pub ecc_aggr1_ecc_aggr: EccAggr1EccAggr,
    #[doc = "CPSW0_ECC"]
    pub cpsw0_ecc: Cpsw0Ecc,
    #[doc = "MMCSD0_ECC_AGGR_RXMEM"]
    pub mmcsd0_ecc_aggr_rxmem: Mmcsd0EccAggrRxmem,
    #[doc = "MMCSD0_ECC_AGGR_TXMEM"]
    pub mmcsd0_ecc_aggr_txmem: Mmcsd0EccAggrTxmem,
    #[doc = "MMCSD1_ECC_AGGR_RXMEM"]
    pub mmcsd1_ecc_aggr_rxmem: Mmcsd1EccAggrRxmem,
    #[doc = "MMCSD1_ECC_AGGR_TXMEM"]
    pub mmcsd1_ecc_aggr_txmem: Mmcsd1EccAggrTxmem,
    #[doc = "FSS0_OSPI_0_OSPI0_ECC_AGGR"]
    pub fss0_ospi_0_ospi0_ecc_aggr: Fss0Ospi0Ospi0EccAggr,
    #[doc = "A53SS0_SS_ECC_AGGR"]
    pub a53ss0_ss_ecc_aggr: A53ss0SsEccAggr,
    #[doc = "A53SS0_CORE0_ECC_AGGR"]
    pub a53ss0_core0_ecc_aggr: A53ss0Core0EccAggr,
    #[doc = "A53SS0_CORE1_ECC_AGGR"]
    pub a53ss0_core1_ecc_aggr: A53ss0Core1EccAggr,
    #[doc = "ADC0_ECC_REGS"]
    pub adc0_ecc_regs: Adc0EccRegs,
    #[doc = "DCC0"]
    pub dcc0: Dcc0,
    #[doc = "DCC1"]
    pub dcc1: Dcc1,
    #[doc = "DCC2"]
    pub dcc2: Dcc2,
    #[doc = "DCC3"]
    pub dcc3: Dcc3,
    #[doc = "DCC4"]
    pub dcc4: Dcc4,
    #[doc = "DCC5"]
    pub dcc5: Dcc5,
    #[doc = "MAIN_GPIOMUX_INTROUTER0_CFG"]
    pub main_gpiomux_introuter0_cfg: MainGpiomuxIntrouter0Cfg,
    #[doc = "CMP_EVENT_INTROUTER0_CFG"]
    pub cmp_event_introuter0_cfg: CmpEventIntrouter0Cfg,
    #[doc = "TIMESYNC_EVENT_INTROUTER0_CFG"]
    pub timesync_event_introuter0_cfg: TimesyncEventIntrouter0Cfg,
    #[doc = "GTC0_GTC_CFG0"]
    pub gtc0_gtc_cfg0: Gtc0GtcCfg0,
    #[doc = "GTC0_GTC_CFG1"]
    pub gtc0_gtc_cfg1: Gtc0GtcCfg1,
    #[doc = "GTC0_GTC_CFG2"]
    pub gtc0_gtc_cfg2: Gtc0GtcCfg2,
    #[doc = "GTC0_GTC_CFG3"]
    pub gtc0_gtc_cfg3: Gtc0GtcCfg3,
    #[doc = "VTM0_MMR_VBUSP_CFG1"]
    pub vtm0_mmr_vbusp_cfg1: Vtm0MmrVbuspCfg1,
    #[doc = "VTM0_MMR_VBUSP_CFG2"]
    pub vtm0_mmr_vbusp_cfg2: Vtm0MmrVbuspCfg2,
    #[doc = "VTM0_ECCAGGR_CFG"]
    pub vtm0_eccaggr_cfg: Vtm0EccaggrCfg,
    #[doc = "PDMA0_REGS"]
    pub pdma0_regs: Pdma0Regs,
    #[doc = "PDMA1_REGS"]
    pub pdma1_regs: Pdma1Regs,
    #[doc = "GICSS0_GIC_TRANSLATER"]
    pub gicss0_gic_translater: Gicss0GicTranslater,
    #[doc = "GICSS0_GIC"]
    pub gicss0_gic: Gicss0Gic,
    #[doc = "TIMER0_CFG"]
    pub timer0_cfg: Timer0Cfg,
    #[doc = "TIMER1_CFG"]
    pub timer1_cfg: Timer1Cfg,
    #[doc = "TIMER2_CFG"]
    pub timer2_cfg: Timer2Cfg,
    #[doc = "TIMER3_CFG"]
    pub timer3_cfg: Timer3Cfg,
    #[doc = "TIMER4_CFG"]
    pub timer4_cfg: Timer4Cfg,
    #[doc = "TIMER5_CFG"]
    pub timer5_cfg: Timer5Cfg,
    #[doc = "TIMER6_CFG"]
    pub timer6_cfg: Timer6Cfg,
    #[doc = "TIMER7_CFG"]
    pub timer7_cfg: Timer7Cfg,
    #[doc = "TIMER8_CFG"]
    pub timer8_cfg: Timer8Cfg,
    #[doc = "TIMER9_CFG"]
    pub timer9_cfg: Timer9Cfg,
    #[doc = "TIMER10_CFG"]
    pub timer10_cfg: Timer10Cfg,
    #[doc = "TIMER11_CFG"]
    pub timer11_cfg: Timer11Cfg,
    #[doc = "UART0"]
    pub uart0: Uart0,
    #[doc = "UART1"]
    pub uart1: Uart1,
    #[doc = "UART2"]
    pub uart2: Uart2,
    #[doc = "UART3"]
    pub uart3: Uart3,
    #[doc = "UART4"]
    pub uart4: Uart4,
    #[doc = "UART5"]
    pub uart5: Uart5,
    #[doc = "UART6"]
    pub uart6: Uart6,
    #[doc = "MCU_PSC0"]
    pub mcu_psc0: McuPsc0,
    #[doc = "MCU_PLL0_CFG"]
    pub mcu_pll0_cfg: McuPll0Cfg,
    #[doc = "MCU_PADCFG_CTRL0_CFG0"]
    pub mcu_padcfg_ctrl0_cfg0: McuPadcfgCtrl0Cfg0,
    #[doc = "MCU_ESM0_CFG"]
    pub mcu_esm0_cfg: McuEsm0Cfg,
    #[doc = "MCU_GPIO0"]
    pub mcu_gpio0: McuGpio0,
    #[doc = "MCU_MCU_GPIOMUX_INTROUTER0_CFG"]
    pub mcu_mcu_gpiomux_introuter0_cfg: McuMcuGpiomuxIntrouter0Cfg,
    #[doc = "MCU_TIMEOUT0_CFG"]
    pub mcu_timeout0_cfg: McuTimeout0Cfg,
    #[doc = "MCU_CTRL_MMR0_CFG0"]
    pub mcu_ctrl_mmr0_cfg0: McuCtrlMmr0Cfg0,
    #[doc = "MCU_ECC_AGGR0_ECC_AGGR"]
    pub mcu_ecc_aggr0_ecc_aggr: McuEccAggr0EccAggr,
    #[doc = "MCU_CBASS0_ERR"]
    pub mcu_cbass0_err: McuCbass0Err,
    #[doc = "MCU_TIMER0_CFG"]
    pub mcu_timer0_cfg: McuTimer0Cfg,
    #[doc = "MCU_TIMER1_CFG"]
    pub mcu_timer1_cfg: McuTimer1Cfg,
    #[doc = "MCU_TIMER2_CFG"]
    pub mcu_timer2_cfg: McuTimer2Cfg,
    #[doc = "MCU_TIMER3_CFG"]
    pub mcu_timer3_cfg: McuTimer3Cfg,
    #[doc = "MCU_RTI0_CFG"]
    pub mcu_rti0_cfg: McuRti0Cfg,
    #[doc = "MCU_I2C0_CFG"]
    pub mcu_i2c0_cfg: McuI2c0Cfg,
    #[doc = "MCU_I2C1_CFG"]
    pub mcu_i2c1_cfg: McuI2c1Cfg,
    #[doc = "MCU_UART0"]
    pub mcu_uart0: McuUart0,
    #[doc = "MCU_UART1"]
    pub mcu_uart1: McuUart1,
    #[doc = "MCU_MCSPI0_CFG"]
    pub mcu_mcspi0_cfg: McuMcspi0Cfg,
    #[doc = "MCU_MCSPI1_CFG"]
    pub mcu_mcspi1_cfg: McuMcspi1Cfg,
    #[doc = "MCU_DCC0"]
    pub mcu_dcc0: McuDcc0,
    #[doc = "MCU_MCRC64_0_REGS"]
    pub mcu_mcrc64_0_regs: McuMcrc64_0Regs,
    #[doc = "MCU_M4FSS0_IRAM_0_IRAM"]
    pub mcu_m4fss0_iram_0_iram: McuM4fss0Iram0Iram,
    #[doc = "MCU_M4FSS0_DRAM_0_DRAM"]
    pub mcu_m4fss0_dram_0_dram: McuM4fss0Dram0Dram,
    #[doc = "MCU_M4FSS0_RAT_0_RAT"]
    pub mcu_m4fss0_rat_0_rat: McuM4fss0Rat0Rat,
    #[doc = "MCU_M4FSS0_ECC_AGGR_0_ECC_AGGR"]
    pub mcu_m4fss0_ecc_aggr_0_ecc_aggr: McuM4fss0EccAggr0EccAggr,
    #[doc = "CPSW0_NUSS"]
    pub cpsw0_nuss: Cpsw0Nuss,
    #[doc = "RTI0_CFG"]
    pub rti0_cfg: Rti0Cfg,
    #[doc = "RTI1_CFG"]
    pub rti1_cfg: Rti1Cfg,
    #[doc = "RTI8_CFG"]
    pub rti8_cfg: Rti8Cfg,
    #[doc = "RTI9_CFG"]
    pub rti9_cfg: Rti9Cfg,
    #[doc = "RTI10_CFG"]
    pub rti10_cfg: Rti10Cfg,
    #[doc = "RTI11_CFG"]
    pub rti11_cfg: Rti11Cfg,
    #[doc = "DDR16SS0_SS_CFG"]
    pub ddr16ss0_ss_cfg: Ddr16ss0SsCfg,
    #[doc = "DDR16SS0_CTLPHY_WRAP_CTL_CFG_CTLCFG"]
    pub ddr16ss0_ctlphy_wrap_ctl_cfg_ctlcfg: Ddr16ss0CtlphyWrapCtlCfgCtlcfg,
    #[doc = "MMCSD1_CTL_CFG"]
    pub mmcsd1_ctl_cfg: Mmcsd1CtlCfg,
    #[doc = "MMCSD1_SS_CFG"]
    pub mmcsd1_ss_cfg: Mmcsd1SsCfg,
    #[doc = "MMCSD0_CTL_CFG"]
    pub mmcsd0_ctl_cfg: Mmcsd0CtlCfg,
    #[doc = "MMCSD0_SS_CFG"]
    pub mmcsd0_ss_cfg: Mmcsd0SsCfg,
    #[doc = "FSS0_CFG"]
    pub fss0_cfg: Fss0Cfg,
    #[doc = "FSS0_FSAS_0_FSAS_CFG"]
    pub fss0_fsas_0_fsas_cfg: Fss0Fsas0FsasCfg,
    #[doc = "FSS0_FSAS_0_OTFA_CFG"]
    pub fss0_fsas_0_otfa_cfg: Fss0Fsas0OtfaCfg,
    #[doc = "FSS0_OSPI_0_OSPI0_CTRL"]
    pub fss0_ospi_0_ospi0_ctrl: Fss0Ospi0Ospi0Ctrl,
    #[doc = "FSS0_OSPI_0_OSPI0_SS_CFG"]
    pub fss0_ospi_0_ospi0_ss_cfg: Fss0Ospi0Ospi0SsCfg,
    #[doc = "I2C0_CFG"]
    pub i2c0_cfg: I2c0Cfg,
    #[doc = "I2C1_CFG"]
    pub i2c1_cfg: I2c1Cfg,
    #[doc = "I2C2_CFG"]
    pub i2c2_cfg: I2c2Cfg,
    #[doc = "I2C3_CFG"]
    pub i2c3_cfg: I2c3Cfg,
    #[doc = "MCSPI0_CFG"]
    pub mcspi0_cfg: Mcspi0Cfg,
    #[doc = "MCSPI1_CFG"]
    pub mcspi1_cfg: Mcspi1Cfg,
    #[doc = "MCSPI2_CFG"]
    pub mcspi2_cfg: Mcspi2Cfg,
    #[doc = "MCSPI3_CFG"]
    pub mcspi3_cfg: Mcspi3Cfg,
    #[doc = "MCSPI4_CFG"]
    pub mcspi4_cfg: Mcspi4Cfg,
    #[doc = "MCAN0_SS"]
    pub mcan0_ss: Mcan0Ss,
    #[doc = "MCAN0_CFG"]
    pub mcan0_cfg: Mcan0Cfg,
    #[doc = "MCAN1_SS"]
    pub mcan1_ss: Mcan1Ss,
    #[doc = "MCAN1_CFG"]
    pub mcan1_cfg: Mcan1Cfg,
    #[doc = "EPWM0_EPWM"]
    pub epwm0_epwm: Epwm0Epwm,
    #[doc = "EPWM1_EPWM"]
    pub epwm1_epwm: Epwm1Epwm,
    #[doc = "EPWM2_EPWM"]
    pub epwm2_epwm: Epwm2Epwm,
    #[doc = "EPWM3_EPWM"]
    pub epwm3_epwm: Epwm3Epwm,
    #[doc = "EPWM4_EPWM"]
    pub epwm4_epwm: Epwm4Epwm,
    #[doc = "EPWM5_EPWM"]
    pub epwm5_epwm: Epwm5Epwm,
    #[doc = "EPWM6_EPWM"]
    pub epwm6_epwm: Epwm6Epwm,
    #[doc = "EPWM7_EPWM"]
    pub epwm7_epwm: Epwm7Epwm,
    #[doc = "EPWM8_EPWM"]
    pub epwm8_epwm: Epwm8Epwm,
    #[doc = "ECAP0_CTL_STS"]
    pub ecap0_ctl_sts: Ecap0CtlSts,
    #[doc = "ECAP1_CTL_STS"]
    pub ecap1_ctl_sts: Ecap1CtlSts,
    #[doc = "ECAP2_CTL_STS"]
    pub ecap2_ctl_sts: Ecap2CtlSts,
    #[doc = "EQEP0_REG"]
    pub eqep0_reg: Eqep0Reg,
    #[doc = "EQEP1_REG"]
    pub eqep1_reg: Eqep1Reg,
    #[doc = "EQEP2_REG"]
    pub eqep2_reg: Eqep2Reg,
    #[doc = "FSIRX0_CFG"]
    pub fsirx0_cfg: Fsirx0Cfg,
    #[doc = "FSIRX1_CFG"]
    pub fsirx1_cfg: Fsirx1Cfg,
    #[doc = "FSIRX2_CFG"]
    pub fsirx2_cfg: Fsirx2Cfg,
    #[doc = "FSIRX3_CFG"]
    pub fsirx3_cfg: Fsirx3Cfg,
    #[doc = "FSIRX4_CFG"]
    pub fsirx4_cfg: Fsirx4Cfg,
    #[doc = "FSIRX5_CFG"]
    pub fsirx5_cfg: Fsirx5Cfg,
    #[doc = "FSITX0_CFG"]
    pub fsitx0_cfg: Fsitx0Cfg,
    #[doc = "FSITX1_CFG"]
    pub fsitx1_cfg: Fsitx1Cfg,
    #[doc = "MCAN0_ECC_AGGR"]
    pub mcan0_ecc_aggr: Mcan0EccAggr,
    #[doc = "MCAN1_ECC_AGGR"]
    pub mcan1_ecc_aggr: Mcan1EccAggr,
    #[doc = "ELM0"]
    pub elm0: Elm0,
    #[doc = "ADC0_FIFO"]
    pub adc0_fifo: Adc0Fifo,
    #[doc = "ADC0"]
    pub adc0: Adc0,
    #[doc = "MAILBOX0_MAILBOX_CLUSTER_0_REGS0"]
    pub mailbox0_mailbox_cluster_0_regs0: Mailbox0MailboxCluster0Regs0,
    #[doc = "MAILBOX0_MAILBOX_CLUSTER_1_REGS1"]
    pub mailbox0_mailbox_cluster_1_regs1: Mailbox0MailboxCluster1Regs1,
    #[doc = "MAILBOX0_MAILBOX_CLUSTER_2_REGS2"]
    pub mailbox0_mailbox_cluster_2_regs2: Mailbox0MailboxCluster2Regs2,
    #[doc = "MAILBOX0_MAILBOX_CLUSTER_3_REGS3"]
    pub mailbox0_mailbox_cluster_3_regs3: Mailbox0MailboxCluster3Regs3,
    #[doc = "MAILBOX0_MAILBOX_CLUSTER_4_REGS4"]
    pub mailbox0_mailbox_cluster_4_regs4: Mailbox0MailboxCluster4Regs4,
    #[doc = "MAILBOX0_MAILBOX_CLUSTER_5_REGS5"]
    pub mailbox0_mailbox_cluster_5_regs5: Mailbox0MailboxCluster5Regs5,
    #[doc = "MAILBOX0_MAILBOX_CLUSTER_6_REGS6"]
    pub mailbox0_mailbox_cluster_6_regs6: Mailbox0MailboxCluster6Regs6,
    #[doc = "MAILBOX0_MAILBOX_CLUSTER_7_REGS7"]
    pub mailbox0_mailbox_cluster_7_regs7: Mailbox0MailboxCluster7Regs7,
    #[doc = "SPINLOCK0"]
    pub spinlock0: Spinlock0,
    #[doc = "PRU_ICSSG0_DRAM0_SLV_RAM"]
    pub pru_icssg0_dram0_slv_ram: PruIcssg0Dram0SlvRam,
    #[doc = "PRU_ICSSG0_DRAM1_SLV_RAM"]
    pub pru_icssg0_dram1_slv_ram: PruIcssg0Dram1SlvRam,
    #[doc = "PRU_ICSSG0_RAT_SLICE0_CFG"]
    pub pru_icssg0_rat_slice0_cfg: PruIcssg0RatSlice0Cfg,
    #[doc = "PRU_ICSSG0_RAT_SLICE1_CFG"]
    pub pru_icssg0_rat_slice1_cfg: PruIcssg0RatSlice1Cfg,
    #[doc = "PRU_ICSSG0_RAM_SLV_RAM"]
    pub pru_icssg0_ram_slv_ram: PruIcssg0RamSlvRam,
    #[doc = "PRU_ICSSG0_PR1_ICSS_INTC_INTC_SLV"]
    pub pru_icssg0_pr1_icss_intc_intc_slv: PruIcssg0Pr1IcssIntcIntcSlv,
    #[doc = "PRU_ICSSG0_PR1_PROT_SLV"]
    pub pru_icssg0_pr1_prot_slv: PruIcssg0Pr1ProtSlv,
    #[doc = "PRU_ICSSG0_PR1_CFG_SLV"]
    pub pru_icssg0_pr1_cfg_slv: PruIcssg0Pr1CfgSlv,
    #[doc = "PRU_ICSSG0_PA_STAT_WRAP_PA_SLV_QSTAT"]
    pub pru_icssg0_pa_stat_wrap_pa_slv_qstat: PruIcssg0PaStatWrapPaSlvQstat,
    #[doc = "PRU_ICSSG0_PR1_ICSS_UART_UART_SLV"]
    pub pru_icssg0_pr1_icss_uart_uart_slv: PruIcssg0Pr1IcssUartUartSlv,
    #[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU0_PR1_TASKS_MGR_PRU0_MMR"]
    pub pru_icssg0_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr:
        PruIcssg0Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr,
    #[doc = "PRU_ICSSG0_PR1_TASKS_MGR_RTU0_PR1_TASKS_MGR_RTU0_MMR"]
    pub pru_icssg0_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr:
        PruIcssg0Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr,
    #[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU1_PR1_TASKS_MGR_PRU1_MMR"]
    pub pru_icssg0_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr:
        PruIcssg0Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr,
    #[doc = "PRU_ICSSG0_PR1_TASKS_MGR_RTU1_PR1_TASKS_MGR_RTU1_MMR"]
    pub pru_icssg0_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr:
        PruIcssg0Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr,
    #[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU_TX0_PR1_TASKS_MGR_PRU_TX0_MMR"]
    pub pru_icssg0_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr:
        PruIcssg0Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr,
    #[doc = "PRU_ICSSG0_PR1_TASKS_MGR_PRU_TX1_PR1_TASKS_MGR_PRU_TX1_MMR"]
    pub pru_icssg0_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr:
        PruIcssg0Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr,
    #[doc = "PRU_ICSSG0_PA_STAT_WRAP_PA_SLV_CSTAT"]
    pub pru_icssg0_pa_stat_wrap_pa_slv_cstat: PruIcssg0PaStatWrapPaSlvCstat,
    #[doc = "PRU_ICSSG0_IEP0"]
    pub pru_icssg0_iep0: PruIcssg0Iep0,
    #[doc = "PRU_ICSSG0_IEP1"]
    pub pru_icssg0_iep1: PruIcssg0Iep1,
    #[doc = "PRU_ICSSG0_PR1_ICSS_ECAP0_ECAP_SLV"]
    pub pru_icssg0_pr1_icss_ecap0_ecap_slv: PruIcssg0Pr1IcssEcap0EcapSlv,
    #[doc = "PRU_ICSSG0_PR1_MII_RT_PR1_MII_RT_CFG"]
    pub pru_icssg0_pr1_mii_rt_pr1_mii_rt_cfg: PruIcssg0Pr1MiiRtPr1MiiRtCfg,
    #[doc = "PRU_ICSSG0_PR1_MDIO_V1P7_MDIO"]
    pub pru_icssg0_pr1_mdio_v1p7_mdio: PruIcssg0Pr1MdioV1p7Mdio,
    #[doc = "PRU_ICSSG0_PR1_MII_RT_PR1_MII_RT_G_CFG_REGS_G"]
    pub pru_icssg0_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g: PruIcssg0Pr1MiiRtPr1MiiRtGCfgRegsG,
    #[doc = "PRU_ICSSG1_DRAM0_SLV_RAM"]
    pub pru_icssg1_dram0_slv_ram: PruIcssg1Dram0SlvRam,
    #[doc = "PRU_ICSSG1_DRAM1_SLV_RAM"]
    pub pru_icssg1_dram1_slv_ram: PruIcssg1Dram1SlvRam,
    #[doc = "PRU_ICSSG1_RAT_SLICE0_CFG"]
    pub pru_icssg1_rat_slice0_cfg: PruIcssg1RatSlice0Cfg,
    #[doc = "PRU_ICSSG1_RAT_SLICE1_CFG"]
    pub pru_icssg1_rat_slice1_cfg: PruIcssg1RatSlice1Cfg,
    #[doc = "PRU_ICSSG1_RAM_SLV_RAM"]
    pub pru_icssg1_ram_slv_ram: PruIcssg1RamSlvRam,
    #[doc = "PRU_ICSSG1_PR1_ICSS_INTC_INTC_SLV"]
    pub pru_icssg1_pr1_icss_intc_intc_slv: PruIcssg1Pr1IcssIntcIntcSlv,
    #[doc = "PRU_ICSSG1_PR1_PROT_SLV"]
    pub pru_icssg1_pr1_prot_slv: PruIcssg1Pr1ProtSlv,
    #[doc = "PRU_ICSSG1_PR1_CFG_SLV"]
    pub pru_icssg1_pr1_cfg_slv: PruIcssg1Pr1CfgSlv,
    #[doc = "PRU_ICSSG1_PA_STAT_WRAP_PA_SLV_QSTAT"]
    pub pru_icssg1_pa_stat_wrap_pa_slv_qstat: PruIcssg1PaStatWrapPaSlvQstat,
    #[doc = "PRU_ICSSG1_PR1_ICSS_UART_UART_SLV"]
    pub pru_icssg1_pr1_icss_uart_uart_slv: PruIcssg1Pr1IcssUartUartSlv,
    #[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU0_PR1_TASKS_MGR_PRU0_MMR"]
    pub pru_icssg1_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr:
        PruIcssg1Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr,
    #[doc = "PRU_ICSSG1_PR1_TASKS_MGR_RTU0_PR1_TASKS_MGR_RTU0_MMR"]
    pub pru_icssg1_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr:
        PruIcssg1Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr,
    #[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU1_PR1_TASKS_MGR_PRU1_MMR"]
    pub pru_icssg1_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr:
        PruIcssg1Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr,
    #[doc = "PRU_ICSSG1_PR1_TASKS_MGR_RTU1_PR1_TASKS_MGR_RTU1_MMR"]
    pub pru_icssg1_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr:
        PruIcssg1Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr,
    #[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU_TX0_PR1_TASKS_MGR_PRU_TX0_MMR"]
    pub pru_icssg1_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr:
        PruIcssg1Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr,
    #[doc = "PRU_ICSSG1_PR1_TASKS_MGR_PRU_TX1_PR1_TASKS_MGR_PRU_TX1_MMR"]
    pub pru_icssg1_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr:
        PruIcssg1Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr,
    #[doc = "PRU_ICSSG1_PA_STAT_WRAP_PA_SLV_CSTAT"]
    pub pru_icssg1_pa_stat_wrap_pa_slv_cstat: PruIcssg1PaStatWrapPaSlvCstat,
    #[doc = "PRU_ICSSG1_IEP0"]
    pub pru_icssg1_iep0: PruIcssg1Iep0,
    #[doc = "PRU_ICSSG1_IEP1"]
    pub pru_icssg1_iep1: PruIcssg1Iep1,
    #[doc = "PRU_ICSSG1_PR1_ICSS_ECAP0_ECAP_SLV"]
    pub pru_icssg1_pr1_icss_ecap0_ecap_slv: PruIcssg1Pr1IcssEcap0EcapSlv,
    #[doc = "PRU_ICSSG1_PR1_MII_RT_PR1_MII_RT_CFG"]
    pub pru_icssg1_pr1_mii_rt_pr1_mii_rt_cfg: PruIcssg1Pr1MiiRtPr1MiiRtCfg,
    #[doc = "PRU_ICSSG1_PR1_MDIO_V1P7_MDIO"]
    pub pru_icssg1_pr1_mdio_v1p7_mdio: PruIcssg1Pr1MdioV1p7Mdio,
    #[doc = "PRU_ICSSG1_PR1_MII_RT_PR1_MII_RT_G_CFG_REGS_G"]
    pub pru_icssg1_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g: PruIcssg1Pr1MiiRtPr1MiiRtGCfgRegsG,
    #[doc = "TIMERMGR0_TIMERS"]
    pub timermgr0_timers: Timermgr0Timers,
    #[doc = "CPTS0"]
    pub cpts0: Cpts0,
    #[doc = "CBASS0_ERR"]
    pub cbass0_err: Cbass0Err,
    #[doc = "GPMC0_CFG"]
    pub gpmc0_cfg: Gpmc0Cfg,
    #[doc = "TIMERMGR0_CONFIG"]
    pub timermgr0_config: Timermgr0Config,
    #[doc = "MSRAM_256K0_ECC_AGGR_REGS"]
    pub msram_256k0_ecc_aggr_regs: Msram256k0EccAggrRegs,
    #[doc = "MSRAM_256K1_ECC_AGGR_REGS"]
    pub msram_256k1_ecc_aggr_regs: Msram256k1EccAggrRegs,
    #[doc = "MSRAM_256K2_ECC_AGGR_REGS"]
    pub msram_256k2_ecc_aggr_regs: Msram256k2EccAggrRegs,
    #[doc = "GICSS0_REGS"]
    pub gicss0_regs: Gicss0Regs,
    #[doc = "DMASS0_ECC_AGGR_0_ECCAGGR"]
    pub dmass0_ecc_aggr_0_eccaggr: Dmass0EccAggr0Eccaggr,
    #[doc = "MSRAM_256K5_ECC_AGGR_REGS"]
    pub msram_256k5_ecc_aggr_regs: Msram256k5EccAggrRegs,
    #[doc = "MSRAM_256K4_ECC_AGGR_REGS"]
    pub msram_256k4_ecc_aggr_regs: Msram256k4EccAggrRegs,
    #[doc = "MSRAM_256K3_ECC_AGGR_REGS"]
    pub msram_256k3_ecc_aggr_regs: Msram256k3EccAggrRegs,
    #[doc = "PRU_ICSSG0_ECC_AGGR"]
    pub pru_icssg0_ecc_aggr: PruIcssg0EccAggr,
    #[doc = "PRU_ICSSG1_ECC_AGGR"]
    pub pru_icssg1_ecc_aggr: PruIcssg1EccAggr,
    #[doc = "ECC_AGGR0_ECC_AGGR"]
    pub ecc_aggr0_ecc_aggr: EccAggr0EccAggr,
    #[doc = "MSRAM_256K6_ECC_AGGR_REGS"]
    pub msram_256k6_ecc_aggr_regs: Msram256k6EccAggrRegs,
    #[doc = "MSRAM_256K7_ECC_AGGR_REGS"]
    pub msram_256k7_ecc_aggr_regs: Msram256k7EccAggrRegs,
    #[doc = "ROM0"]
    pub rom0: Rom0,
    #[doc = "CTRL_MMR0_CFG0"]
    pub ctrl_mmr0_cfg0: CtrlMmr0Cfg0,
    #[doc = "MSRAM_256K7_RAM"]
    pub msram_256k7_ram0: Msram256k7Ram,
    #[doc = "MSRAM_256K7_RAM"]
    pub msram_256k7_ram1: Msram256k7Ram,
    #[doc = "MSRAM_256K6_RAM"]
    pub msram_256k6_ram0: Msram256k6Ram,
    #[doc = "MSRAM_256K6_RAM"]
    pub msram_256k6_ram1: Msram256k6Ram,
    #[doc = "CBASS0_FW"]
    pub cbass0_fw: Cbass0Fw,
    #[doc = "CBASS_INFRA1_FW"]
    pub cbass_infra1_fw: CbassInfra1Fw,
    #[doc = "CBASS_INFRA1_ISC"]
    pub cbass_infra1_isc: CbassInfra1Isc,
    #[doc = "MCU_CBASS0_ISC"]
    pub mcu_cbass0_isc: McuCbass0Isc,
    #[doc = "DMASS0_RINGACC_0_RINGACC_ISC"]
    pub dmass0_ringacc_0_ringacc_isc: Dmass0Ringacc0RingaccIsc,
    #[doc = "CBASS0_ISC"]
    pub cbass0_isc: Cbass0Isc,
    #[doc = "CBASS_INFRA1_GLB"]
    pub cbass_infra1_glb: CbassInfra1Glb,
    #[doc = "MCU_CBASS0_GLB"]
    pub mcu_cbass0_glb: McuCbass0Glb,
    #[doc = "CBASS0_GLB"]
    pub cbass0_glb: Cbass0Glb,
    #[doc = "CBASS_INFRA1_QOS"]
    pub cbass_infra1_qos: CbassInfra1Qos,
    #[doc = "MCU_CBASS0_QOS"]
    pub mcu_cbass0_qos: McuCbass0Qos,
    #[doc = "CBASS0_QOS"]
    pub cbass0_qos: Cbass0Qos,
    #[doc = "DMASS0_INTAGGR_0_INTAGGR_INTR"]
    pub dmass0_intaggr_0_intaggr_intr: Dmass0Intaggr0IntaggrIntr,
    #[doc = "DMASS0_INTAGGR_0_INTAGGR_IMAP"]
    pub dmass0_intaggr_0_intaggr_imap: Dmass0Intaggr0IntaggrImap,
    #[doc = "DMASS0_INTAGGR_0_INTAGGR_CFG"]
    pub dmass0_intaggr_0_intaggr_cfg: Dmass0Intaggr0IntaggrCfg,
    #[doc = "DMASS0_INTAGGR_0_INTAGGR_L2G"]
    pub dmass0_intaggr_0_intaggr_l2g: Dmass0Intaggr0IntaggrL2g,
    #[doc = "DMASS0_PSILCFG_0_PSILCFG_PROXY"]
    pub dmass0_psilcfg_0_psilcfg_proxy: Dmass0Psilcfg0PsilcfgProxy,
    #[doc = "DMASS0_PSILSS_0_PSILSS_MMRS"]
    pub dmass0_psilss_0_psilss_mmrs: Dmass0Psilss0PsilssMmrs,
    #[doc = "DMASS0_INTAGGR_0_INTAGGR_UNMAP"]
    pub dmass0_intaggr_0_intaggr_unmap: Dmass0Intaggr0IntaggrUnmap,
    #[doc = "DMASS0_INTAGGR_0_INTAGGR_MCAST"]
    pub dmass0_intaggr_0_intaggr_mcast: Dmass0Intaggr0IntaggrMcast,
    #[doc = "DMASS0_INTAGGR_0_INTAGGR_GCNTCFG"]
    pub dmass0_intaggr_0_intaggr_gcntcfg: Dmass0Intaggr0IntaggrGcntcfg,
    #[doc = "DMASS0_PSILSS_0_ETLSW_MMRS"]
    pub dmass0_psilss_0_etlsw_mmrs: Dmass0Psilss0EtlswMmrs,
    #[doc = "DMASS0_RINGACC_0_RINGACC_GCFG"]
    pub dmass0_ringacc_0_ringacc_gcfg: Dmass0Ringacc0RingaccGcfg,
    #[doc = "DMASS0_BCDMA_0_BCDMA_CRED"]
    pub dmass0_bcdma_0_bcdma_cred: Dmass0Bcdma0BcdmaCred,
    #[doc = "DMASS0_PKTDMA_0_PKTDMA_CRED"]
    pub dmass0_pktdma_0_pktdma_cred: Dmass0Pktdma0PktdmaCred,
    #[doc = "DMASS0_BCDMA_0_BCDMA_BCHAN"]
    pub dmass0_bcdma_0_bcdma_bchan: Dmass0Bcdma0BcdmaBchan,
    #[doc = "DMASS0_PKTDMA_0_PKTDMA_RFLOW"]
    pub dmass0_pktdma_0_pktdma_rflow: Dmass0Pktdma0PktdmaRflow,
    #[doc = "DMASS0_PKTDMA_0_PKTDMA_TCHAN"]
    pub dmass0_pktdma_0_pktdma_tchan: Dmass0Pktdma0PktdmaTchan,
    #[doc = "DMASS0_BCDMA_0_BCDMA_TCHAN"]
    pub dmass0_bcdma_0_bcdma_tchan: Dmass0Bcdma0BcdmaTchan,
    #[doc = "DMASS0_PKTDMA_0_PKTDMA_RCHAN"]
    pub dmass0_pktdma_0_pktdma_rchan: Dmass0Pktdma0PktdmaRchan,
    #[doc = "DMASS0_BCDMA_0_BCDMA_RCHAN"]
    pub dmass0_bcdma_0_bcdma_rchan: Dmass0Bcdma0BcdmaRchan,
    #[doc = "DMASS0_PKTDMA_0_PKTDMA_GCFG"]
    pub dmass0_pktdma_0_pktdma_gcfg: Dmass0Pktdma0PktdmaGcfg,
    #[doc = "DMASS0_BCDMA_0_BCDMA_GCFG"]
    pub dmass0_bcdma_0_bcdma_gcfg: Dmass0Bcdma0BcdmaGcfg,
    #[doc = "DMASS0_PKTDMA_0_PKTDMA_RING"]
    pub dmass0_pktdma_0_pktdma_ring: Dmass0Pktdma0PktdmaRing,
    #[doc = "DMASS0_BCDMA_0_BCDMA_RING"]
    pub dmass0_bcdma_0_bcdma_ring: Dmass0Bcdma0BcdmaRing,
    #[doc = "DMASS0_RINGACC_0_RINGACC_RT"]
    pub dmass0_ringacc_0_ringacc_rt: Dmass0Ringacc0RingaccRt,
    #[doc = "DMASS0_RINGACC_0_RINGACC_CFG"]
    pub dmass0_ringacc_0_ringacc_cfg: Dmass0Ringacc0RingaccCfg,
    #[doc = "DMASS0_INTAGGR_0_INTAGGR_GCNTRTI"]
    pub dmass0_intaggr_0_intaggr_gcntrti: Dmass0Intaggr0IntaggrGcntrti,
    #[doc = "DMASS0_PKTDMA_0_PKTDMA_RCHANRT"]
    pub dmass0_pktdma_0_pktdma_rchanrt: Dmass0Pktdma0PktdmaRchanrt,
    #[doc = "DMASS0_BCDMA_0_BCDMA_RCHANRT"]
    pub dmass0_bcdma_0_bcdma_rchanrt: Dmass0Bcdma0BcdmaRchanrt,
    #[doc = "DMASS0_PKTDMA_0_PKTDMA_TCHANRT"]
    pub dmass0_pktdma_0_pktdma_tchanrt: Dmass0Pktdma0PktdmaTchanrt,
    #[doc = "DMASS0_BCDMA_0_BCDMA_TCHANRT"]
    pub dmass0_bcdma_0_bcdma_tchanrt: Dmass0Bcdma0BcdmaTchanrt,
    #[doc = "DMASS0_PKTDMA_0_PKTDMA_RINGRT"]
    pub dmass0_pktdma_0_pktdma_ringrt: Dmass0Pktdma0PktdmaRingrt,
    #[doc = "DMASS0_BCDMA_0_BCDMA_RINGRT"]
    pub dmass0_bcdma_0_bcdma_ringrt: Dmass0Bcdma0BcdmaRingrt,
    #[doc = "DMASS0_BCDMA_0_BCDMA_BCHANRT"]
    pub dmass0_bcdma_0_bcdma_bchanrt: Dmass0Bcdma0BcdmaBchanrt,
    #[doc = "DMASS0_RINGACC_0_RINGACC_SRC_FIFOS"]
    pub dmass0_ringacc_0_ringacc_src_fifos: Dmass0Ringacc0RingaccSrcFifos,
    #[doc = "FSS0_FSAS_0_DAT_REG1"]
    pub fss0_fsas_0_dat_reg1: Fss0Fsas0DatReg1,
    #[doc = "MSRAM_256K0_RAM"]
    pub msram_256k0_ram: Msram256k0Ram,
    #[doc = "MSRAM_256K1_RAM"]
    pub msram_256k1_ram: Msram256k1Ram,
    #[doc = "MSRAM_256K2_RAM"]
    pub msram_256k2_ram: Msram256k2Ram,
    #[doc = "MSRAM_256K3_RAM"]
    pub msram_256k3_ram: Msram256k3Ram,
    #[doc = "MSRAM_256K4_RAM"]
    pub msram_256k4_ram: Msram256k4Ram,
    #[doc = "MSRAM_256K5_RAM"]
    pub msram_256k5_ram: Msram256k5Ram,
    #[doc = "MSRAM_256K6_RAM"]
    pub msram_256k6_ram: Msram256k6Ram,
    #[doc = "MSRAM_256K7_RAM"]
    pub msram_256k7_ram: Msram256k7Ram,
    #[doc = "FSS0_FSAS_0_DAT_REG0"]
    pub fss0_fsas_0_dat_reg0: Fss0Fsas0DatReg0,
    #[doc = "FSS0_FSAS_0_DAT_REG3"]
    pub fss0_fsas_0_dat_reg3: Fss0Fsas0DatReg3,
    #[doc = "A53SS0_SS_ROM"]
    pub a53ss0_ss_rom: A53ss0SsRom,
    #[doc = "A53SS0_CORE0_DBG"]
    pub a53ss0_core0_dbg: A53ss0Core0Dbg,
    #[doc = "A53SS0_CORE0_CTI"]
    pub a53ss0_core0_cti: A53ss0Core0Cti,
    #[doc = "A53SS0_CORE0_PMU"]
    pub a53ss0_core0_pmu: A53ss0Core0Pmu,
    #[doc = "A53SS0_CORE0_ETM"]
    pub a53ss0_core0_etm: A53ss0Core0Etm,
    #[doc = "A53SS0_CORE1_DBG"]
    pub a53ss0_core1_dbg: A53ss0Core1Dbg,
    #[doc = "A53SS0_CORE1_PMU"]
    pub a53ss0_core1_pmu: A53ss0Core1Pmu,
    #[doc = "A53SS0_CORE1_ETM"]
    pub a53ss0_core1_etm: A53ss0Core1Etm,
    #[doc = "A53SS0_CORE1_CTI"]
    pub a53ss0_core1_cti: A53ss0Core1Cti,
    #[doc = "STM0_CXSTM"]
    pub stm0_cxstm: Stm0Cxstm,
    #[doc = "STM0_CTI_CSCTI"]
    pub stm0_cti_cscti: Stm0CtiCscti,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            psramecc0_ram: Psramecc0Ram {
                _marker: PhantomData,
            },
            padcfg_ctrl0_cfg0: PadcfgCtrl0Cfg0 {
                _marker: PhantomData,
            },
            cbass_dbg0_err: CbassDbg0Err {
                _marker: PhantomData,
            },
            cbass_infra1_err: CbassInfra1Err {
                _marker: PhantomData,
            },
            cbass_fw0_err: CbassFw0Err {
                _marker: PhantomData,
            },
            psc0: Psc0 {
                _marker: PhantomData,
            },
            esm0_cfg: Esm0Cfg {
                _marker: PhantomData,
            },
            gpio0: Gpio0 {
                _marker: PhantomData,
            },
            gpio1: Gpio1 {
                _marker: PhantomData,
            },
            pll0_cfg: Pll0Cfg {
                _marker: PhantomData,
            },
            psramecc0_ecc_aggr: Psramecc0EccAggr {
                _marker: PhantomData,
            },
            ecc_aggr1_ecc_aggr: EccAggr1EccAggr {
                _marker: PhantomData,
            },
            cpsw0_ecc: Cpsw0Ecc {
                _marker: PhantomData,
            },
            mmcsd0_ecc_aggr_rxmem: Mmcsd0EccAggrRxmem {
                _marker: PhantomData,
            },
            mmcsd0_ecc_aggr_txmem: Mmcsd0EccAggrTxmem {
                _marker: PhantomData,
            },
            mmcsd1_ecc_aggr_rxmem: Mmcsd1EccAggrRxmem {
                _marker: PhantomData,
            },
            mmcsd1_ecc_aggr_txmem: Mmcsd1EccAggrTxmem {
                _marker: PhantomData,
            },
            fss0_ospi_0_ospi0_ecc_aggr: Fss0Ospi0Ospi0EccAggr {
                _marker: PhantomData,
            },
            a53ss0_ss_ecc_aggr: A53ss0SsEccAggr {
                _marker: PhantomData,
            },
            a53ss0_core0_ecc_aggr: A53ss0Core0EccAggr {
                _marker: PhantomData,
            },
            a53ss0_core1_ecc_aggr: A53ss0Core1EccAggr {
                _marker: PhantomData,
            },
            adc0_ecc_regs: Adc0EccRegs {
                _marker: PhantomData,
            },
            dcc0: Dcc0 {
                _marker: PhantomData,
            },
            dcc1: Dcc1 {
                _marker: PhantomData,
            },
            dcc2: Dcc2 {
                _marker: PhantomData,
            },
            dcc3: Dcc3 {
                _marker: PhantomData,
            },
            dcc4: Dcc4 {
                _marker: PhantomData,
            },
            dcc5: Dcc5 {
                _marker: PhantomData,
            },
            main_gpiomux_introuter0_cfg: MainGpiomuxIntrouter0Cfg {
                _marker: PhantomData,
            },
            cmp_event_introuter0_cfg: CmpEventIntrouter0Cfg {
                _marker: PhantomData,
            },
            timesync_event_introuter0_cfg: TimesyncEventIntrouter0Cfg {
                _marker: PhantomData,
            },
            gtc0_gtc_cfg0: Gtc0GtcCfg0 {
                _marker: PhantomData,
            },
            gtc0_gtc_cfg1: Gtc0GtcCfg1 {
                _marker: PhantomData,
            },
            gtc0_gtc_cfg2: Gtc0GtcCfg2 {
                _marker: PhantomData,
            },
            gtc0_gtc_cfg3: Gtc0GtcCfg3 {
                _marker: PhantomData,
            },
            vtm0_mmr_vbusp_cfg1: Vtm0MmrVbuspCfg1 {
                _marker: PhantomData,
            },
            vtm0_mmr_vbusp_cfg2: Vtm0MmrVbuspCfg2 {
                _marker: PhantomData,
            },
            vtm0_eccaggr_cfg: Vtm0EccaggrCfg {
                _marker: PhantomData,
            },
            pdma0_regs: Pdma0Regs {
                _marker: PhantomData,
            },
            pdma1_regs: Pdma1Regs {
                _marker: PhantomData,
            },
            gicss0_gic_translater: Gicss0GicTranslater {
                _marker: PhantomData,
            },
            gicss0_gic: Gicss0Gic {
                _marker: PhantomData,
            },
            timer0_cfg: Timer0Cfg {
                _marker: PhantomData,
            },
            timer1_cfg: Timer1Cfg {
                _marker: PhantomData,
            },
            timer2_cfg: Timer2Cfg {
                _marker: PhantomData,
            },
            timer3_cfg: Timer3Cfg {
                _marker: PhantomData,
            },
            timer4_cfg: Timer4Cfg {
                _marker: PhantomData,
            },
            timer5_cfg: Timer5Cfg {
                _marker: PhantomData,
            },
            timer6_cfg: Timer6Cfg {
                _marker: PhantomData,
            },
            timer7_cfg: Timer7Cfg {
                _marker: PhantomData,
            },
            timer8_cfg: Timer8Cfg {
                _marker: PhantomData,
            },
            timer9_cfg: Timer9Cfg {
                _marker: PhantomData,
            },
            timer10_cfg: Timer10Cfg {
                _marker: PhantomData,
            },
            timer11_cfg: Timer11Cfg {
                _marker: PhantomData,
            },
            uart0: Uart0 {
                _marker: PhantomData,
            },
            uart1: Uart1 {
                _marker: PhantomData,
            },
            uart2: Uart2 {
                _marker: PhantomData,
            },
            uart3: Uart3 {
                _marker: PhantomData,
            },
            uart4: Uart4 {
                _marker: PhantomData,
            },
            uart5: Uart5 {
                _marker: PhantomData,
            },
            uart6: Uart6 {
                _marker: PhantomData,
            },
            mcu_psc0: McuPsc0 {
                _marker: PhantomData,
            },
            mcu_pll0_cfg: McuPll0Cfg {
                _marker: PhantomData,
            },
            mcu_padcfg_ctrl0_cfg0: McuPadcfgCtrl0Cfg0 {
                _marker: PhantomData,
            },
            mcu_esm0_cfg: McuEsm0Cfg {
                _marker: PhantomData,
            },
            mcu_gpio0: McuGpio0 {
                _marker: PhantomData,
            },
            mcu_mcu_gpiomux_introuter0_cfg: McuMcuGpiomuxIntrouter0Cfg {
                _marker: PhantomData,
            },
            mcu_timeout0_cfg: McuTimeout0Cfg {
                _marker: PhantomData,
            },
            mcu_ctrl_mmr0_cfg0: McuCtrlMmr0Cfg0 {
                _marker: PhantomData,
            },
            mcu_ecc_aggr0_ecc_aggr: McuEccAggr0EccAggr {
                _marker: PhantomData,
            },
            mcu_cbass0_err: McuCbass0Err {
                _marker: PhantomData,
            },
            mcu_timer0_cfg: McuTimer0Cfg {
                _marker: PhantomData,
            },
            mcu_timer1_cfg: McuTimer1Cfg {
                _marker: PhantomData,
            },
            mcu_timer2_cfg: McuTimer2Cfg {
                _marker: PhantomData,
            },
            mcu_timer3_cfg: McuTimer3Cfg {
                _marker: PhantomData,
            },
            mcu_rti0_cfg: McuRti0Cfg {
                _marker: PhantomData,
            },
            mcu_i2c0_cfg: McuI2c0Cfg {
                _marker: PhantomData,
            },
            mcu_i2c1_cfg: McuI2c1Cfg {
                _marker: PhantomData,
            },
            mcu_uart0: McuUart0 {
                _marker: PhantomData,
            },
            mcu_uart1: McuUart1 {
                _marker: PhantomData,
            },
            mcu_mcspi0_cfg: McuMcspi0Cfg {
                _marker: PhantomData,
            },
            mcu_mcspi1_cfg: McuMcspi1Cfg {
                _marker: PhantomData,
            },
            mcu_dcc0: McuDcc0 {
                _marker: PhantomData,
            },
            mcu_mcrc64_0_regs: McuMcrc64_0Regs {
                _marker: PhantomData,
            },
            mcu_m4fss0_iram_0_iram: McuM4fss0Iram0Iram {
                _marker: PhantomData,
            },
            mcu_m4fss0_dram_0_dram: McuM4fss0Dram0Dram {
                _marker: PhantomData,
            },
            mcu_m4fss0_rat_0_rat: McuM4fss0Rat0Rat {
                _marker: PhantomData,
            },
            mcu_m4fss0_ecc_aggr_0_ecc_aggr: McuM4fss0EccAggr0EccAggr {
                _marker: PhantomData,
            },
            cpsw0_nuss: Cpsw0Nuss {
                _marker: PhantomData,
            },
            rti0_cfg: Rti0Cfg {
                _marker: PhantomData,
            },
            rti1_cfg: Rti1Cfg {
                _marker: PhantomData,
            },
            rti8_cfg: Rti8Cfg {
                _marker: PhantomData,
            },
            rti9_cfg: Rti9Cfg {
                _marker: PhantomData,
            },
            rti10_cfg: Rti10Cfg {
                _marker: PhantomData,
            },
            rti11_cfg: Rti11Cfg {
                _marker: PhantomData,
            },
            ddr16ss0_ss_cfg: Ddr16ss0SsCfg {
                _marker: PhantomData,
            },
            ddr16ss0_ctlphy_wrap_ctl_cfg_ctlcfg: Ddr16ss0CtlphyWrapCtlCfgCtlcfg {
                _marker: PhantomData,
            },
            mmcsd1_ctl_cfg: Mmcsd1CtlCfg {
                _marker: PhantomData,
            },
            mmcsd1_ss_cfg: Mmcsd1SsCfg {
                _marker: PhantomData,
            },
            mmcsd0_ctl_cfg: Mmcsd0CtlCfg {
                _marker: PhantomData,
            },
            mmcsd0_ss_cfg: Mmcsd0SsCfg {
                _marker: PhantomData,
            },
            fss0_cfg: Fss0Cfg {
                _marker: PhantomData,
            },
            fss0_fsas_0_fsas_cfg: Fss0Fsas0FsasCfg {
                _marker: PhantomData,
            },
            fss0_fsas_0_otfa_cfg: Fss0Fsas0OtfaCfg {
                _marker: PhantomData,
            },
            fss0_ospi_0_ospi0_ctrl: Fss0Ospi0Ospi0Ctrl {
                _marker: PhantomData,
            },
            fss0_ospi_0_ospi0_ss_cfg: Fss0Ospi0Ospi0SsCfg {
                _marker: PhantomData,
            },
            i2c0_cfg: I2c0Cfg {
                _marker: PhantomData,
            },
            i2c1_cfg: I2c1Cfg {
                _marker: PhantomData,
            },
            i2c2_cfg: I2c2Cfg {
                _marker: PhantomData,
            },
            i2c3_cfg: I2c3Cfg {
                _marker: PhantomData,
            },
            mcspi0_cfg: Mcspi0Cfg {
                _marker: PhantomData,
            },
            mcspi1_cfg: Mcspi1Cfg {
                _marker: PhantomData,
            },
            mcspi2_cfg: Mcspi2Cfg {
                _marker: PhantomData,
            },
            mcspi3_cfg: Mcspi3Cfg {
                _marker: PhantomData,
            },
            mcspi4_cfg: Mcspi4Cfg {
                _marker: PhantomData,
            },
            mcan0_ss: Mcan0Ss {
                _marker: PhantomData,
            },
            mcan0_cfg: Mcan0Cfg {
                _marker: PhantomData,
            },
            mcan1_ss: Mcan1Ss {
                _marker: PhantomData,
            },
            mcan1_cfg: Mcan1Cfg {
                _marker: PhantomData,
            },
            epwm0_epwm: Epwm0Epwm {
                _marker: PhantomData,
            },
            epwm1_epwm: Epwm1Epwm {
                _marker: PhantomData,
            },
            epwm2_epwm: Epwm2Epwm {
                _marker: PhantomData,
            },
            epwm3_epwm: Epwm3Epwm {
                _marker: PhantomData,
            },
            epwm4_epwm: Epwm4Epwm {
                _marker: PhantomData,
            },
            epwm5_epwm: Epwm5Epwm {
                _marker: PhantomData,
            },
            epwm6_epwm: Epwm6Epwm {
                _marker: PhantomData,
            },
            epwm7_epwm: Epwm7Epwm {
                _marker: PhantomData,
            },
            epwm8_epwm: Epwm8Epwm {
                _marker: PhantomData,
            },
            ecap0_ctl_sts: Ecap0CtlSts {
                _marker: PhantomData,
            },
            ecap1_ctl_sts: Ecap1CtlSts {
                _marker: PhantomData,
            },
            ecap2_ctl_sts: Ecap2CtlSts {
                _marker: PhantomData,
            },
            eqep0_reg: Eqep0Reg {
                _marker: PhantomData,
            },
            eqep1_reg: Eqep1Reg {
                _marker: PhantomData,
            },
            eqep2_reg: Eqep2Reg {
                _marker: PhantomData,
            },
            fsirx0_cfg: Fsirx0Cfg {
                _marker: PhantomData,
            },
            fsirx1_cfg: Fsirx1Cfg {
                _marker: PhantomData,
            },
            fsirx2_cfg: Fsirx2Cfg {
                _marker: PhantomData,
            },
            fsirx3_cfg: Fsirx3Cfg {
                _marker: PhantomData,
            },
            fsirx4_cfg: Fsirx4Cfg {
                _marker: PhantomData,
            },
            fsirx5_cfg: Fsirx5Cfg {
                _marker: PhantomData,
            },
            fsitx0_cfg: Fsitx0Cfg {
                _marker: PhantomData,
            },
            fsitx1_cfg: Fsitx1Cfg {
                _marker: PhantomData,
            },
            mcan0_ecc_aggr: Mcan0EccAggr {
                _marker: PhantomData,
            },
            mcan1_ecc_aggr: Mcan1EccAggr {
                _marker: PhantomData,
            },
            elm0: Elm0 {
                _marker: PhantomData,
            },
            adc0_fifo: Adc0Fifo {
                _marker: PhantomData,
            },
            adc0: Adc0 {
                _marker: PhantomData,
            },
            mailbox0_mailbox_cluster_0_regs0: Mailbox0MailboxCluster0Regs0 {
                _marker: PhantomData,
            },
            mailbox0_mailbox_cluster_1_regs1: Mailbox0MailboxCluster1Regs1 {
                _marker: PhantomData,
            },
            mailbox0_mailbox_cluster_2_regs2: Mailbox0MailboxCluster2Regs2 {
                _marker: PhantomData,
            },
            mailbox0_mailbox_cluster_3_regs3: Mailbox0MailboxCluster3Regs3 {
                _marker: PhantomData,
            },
            mailbox0_mailbox_cluster_4_regs4: Mailbox0MailboxCluster4Regs4 {
                _marker: PhantomData,
            },
            mailbox0_mailbox_cluster_5_regs5: Mailbox0MailboxCluster5Regs5 {
                _marker: PhantomData,
            },
            mailbox0_mailbox_cluster_6_regs6: Mailbox0MailboxCluster6Regs6 {
                _marker: PhantomData,
            },
            mailbox0_mailbox_cluster_7_regs7: Mailbox0MailboxCluster7Regs7 {
                _marker: PhantomData,
            },
            spinlock0: Spinlock0 {
                _marker: PhantomData,
            },
            pru_icssg0_dram0_slv_ram: PruIcssg0Dram0SlvRam {
                _marker: PhantomData,
            },
            pru_icssg0_dram1_slv_ram: PruIcssg0Dram1SlvRam {
                _marker: PhantomData,
            },
            pru_icssg0_rat_slice0_cfg: PruIcssg0RatSlice0Cfg {
                _marker: PhantomData,
            },
            pru_icssg0_rat_slice1_cfg: PruIcssg0RatSlice1Cfg {
                _marker: PhantomData,
            },
            pru_icssg0_ram_slv_ram: PruIcssg0RamSlvRam {
                _marker: PhantomData,
            },
            pru_icssg0_pr1_icss_intc_intc_slv: PruIcssg0Pr1IcssIntcIntcSlv {
                _marker: PhantomData,
            },
            pru_icssg0_pr1_prot_slv: PruIcssg0Pr1ProtSlv {
                _marker: PhantomData,
            },
            pru_icssg0_pr1_cfg_slv: PruIcssg0Pr1CfgSlv {
                _marker: PhantomData,
            },
            pru_icssg0_pa_stat_wrap_pa_slv_qstat: PruIcssg0PaStatWrapPaSlvQstat {
                _marker: PhantomData,
            },
            pru_icssg0_pr1_icss_uart_uart_slv: PruIcssg0Pr1IcssUartUartSlv {
                _marker: PhantomData,
            },
            pru_icssg0_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr:
                PruIcssg0Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {
                    _marker: PhantomData,
                },
            pru_icssg0_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr:
                PruIcssg0Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {
                    _marker: PhantomData,
                },
            pru_icssg0_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr:
                PruIcssg0Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {
                    _marker: PhantomData,
                },
            pru_icssg0_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr:
                PruIcssg0Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {
                    _marker: PhantomData,
                },
            pru_icssg0_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr:
                PruIcssg0Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {
                    _marker: PhantomData,
                },
            pru_icssg0_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr:
                PruIcssg0Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {
                    _marker: PhantomData,
                },
            pru_icssg0_pa_stat_wrap_pa_slv_cstat: PruIcssg0PaStatWrapPaSlvCstat {
                _marker: PhantomData,
            },
            pru_icssg0_iep0: PruIcssg0Iep0 {
                _marker: PhantomData,
            },
            pru_icssg0_iep1: PruIcssg0Iep1 {
                _marker: PhantomData,
            },
            pru_icssg0_pr1_icss_ecap0_ecap_slv: PruIcssg0Pr1IcssEcap0EcapSlv {
                _marker: PhantomData,
            },
            pru_icssg0_pr1_mii_rt_pr1_mii_rt_cfg: PruIcssg0Pr1MiiRtPr1MiiRtCfg {
                _marker: PhantomData,
            },
            pru_icssg0_pr1_mdio_v1p7_mdio: PruIcssg0Pr1MdioV1p7Mdio {
                _marker: PhantomData,
            },
            pru_icssg0_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g: PruIcssg0Pr1MiiRtPr1MiiRtGCfgRegsG {
                _marker: PhantomData,
            },
            pru_icssg1_dram0_slv_ram: PruIcssg1Dram0SlvRam {
                _marker: PhantomData,
            },
            pru_icssg1_dram1_slv_ram: PruIcssg1Dram1SlvRam {
                _marker: PhantomData,
            },
            pru_icssg1_rat_slice0_cfg: PruIcssg1RatSlice0Cfg {
                _marker: PhantomData,
            },
            pru_icssg1_rat_slice1_cfg: PruIcssg1RatSlice1Cfg {
                _marker: PhantomData,
            },
            pru_icssg1_ram_slv_ram: PruIcssg1RamSlvRam {
                _marker: PhantomData,
            },
            pru_icssg1_pr1_icss_intc_intc_slv: PruIcssg1Pr1IcssIntcIntcSlv {
                _marker: PhantomData,
            },
            pru_icssg1_pr1_prot_slv: PruIcssg1Pr1ProtSlv {
                _marker: PhantomData,
            },
            pru_icssg1_pr1_cfg_slv: PruIcssg1Pr1CfgSlv {
                _marker: PhantomData,
            },
            pru_icssg1_pa_stat_wrap_pa_slv_qstat: PruIcssg1PaStatWrapPaSlvQstat {
                _marker: PhantomData,
            },
            pru_icssg1_pr1_icss_uart_uart_slv: PruIcssg1Pr1IcssUartUartSlv {
                _marker: PhantomData,
            },
            pru_icssg1_pr1_tasks_mgr_pru0_pr1_tasks_mgr_pru0_mmr:
                PruIcssg1Pr1TasksMgrPru0Pr1TasksMgrPru0Mmr {
                    _marker: PhantomData,
                },
            pru_icssg1_pr1_tasks_mgr_rtu0_pr1_tasks_mgr_rtu0_mmr:
                PruIcssg1Pr1TasksMgrRtu0Pr1TasksMgrRtu0Mmr {
                    _marker: PhantomData,
                },
            pru_icssg1_pr1_tasks_mgr_pru1_pr1_tasks_mgr_pru1_mmr:
                PruIcssg1Pr1TasksMgrPru1Pr1TasksMgrPru1Mmr {
                    _marker: PhantomData,
                },
            pru_icssg1_pr1_tasks_mgr_rtu1_pr1_tasks_mgr_rtu1_mmr:
                PruIcssg1Pr1TasksMgrRtu1Pr1TasksMgrRtu1Mmr {
                    _marker: PhantomData,
                },
            pru_icssg1_pr1_tasks_mgr_pru_tx0_pr1_tasks_mgr_pru_tx0_mmr:
                PruIcssg1Pr1TasksMgrPruTx0Pr1TasksMgrPruTx0Mmr {
                    _marker: PhantomData,
                },
            pru_icssg1_pr1_tasks_mgr_pru_tx1_pr1_tasks_mgr_pru_tx1_mmr:
                PruIcssg1Pr1TasksMgrPruTx1Pr1TasksMgrPruTx1Mmr {
                    _marker: PhantomData,
                },
            pru_icssg1_pa_stat_wrap_pa_slv_cstat: PruIcssg1PaStatWrapPaSlvCstat {
                _marker: PhantomData,
            },
            pru_icssg1_iep0: PruIcssg1Iep0 {
                _marker: PhantomData,
            },
            pru_icssg1_iep1: PruIcssg1Iep1 {
                _marker: PhantomData,
            },
            pru_icssg1_pr1_icss_ecap0_ecap_slv: PruIcssg1Pr1IcssEcap0EcapSlv {
                _marker: PhantomData,
            },
            pru_icssg1_pr1_mii_rt_pr1_mii_rt_cfg: PruIcssg1Pr1MiiRtPr1MiiRtCfg {
                _marker: PhantomData,
            },
            pru_icssg1_pr1_mdio_v1p7_mdio: PruIcssg1Pr1MdioV1p7Mdio {
                _marker: PhantomData,
            },
            pru_icssg1_pr1_mii_rt_pr1_mii_rt_g_cfg_regs_g: PruIcssg1Pr1MiiRtPr1MiiRtGCfgRegsG {
                _marker: PhantomData,
            },
            timermgr0_timers: Timermgr0Timers {
                _marker: PhantomData,
            },
            cpts0: Cpts0 {
                _marker: PhantomData,
            },
            cbass0_err: Cbass0Err {
                _marker: PhantomData,
            },
            gpmc0_cfg: Gpmc0Cfg {
                _marker: PhantomData,
            },
            timermgr0_config: Timermgr0Config {
                _marker: PhantomData,
            },
            msram_256k0_ecc_aggr_regs: Msram256k0EccAggrRegs {
                _marker: PhantomData,
            },
            msram_256k1_ecc_aggr_regs: Msram256k1EccAggrRegs {
                _marker: PhantomData,
            },
            msram_256k2_ecc_aggr_regs: Msram256k2EccAggrRegs {
                _marker: PhantomData,
            },
            gicss0_regs: Gicss0Regs {
                _marker: PhantomData,
            },
            dmass0_ecc_aggr_0_eccaggr: Dmass0EccAggr0Eccaggr {
                _marker: PhantomData,
            },
            msram_256k5_ecc_aggr_regs: Msram256k5EccAggrRegs {
                _marker: PhantomData,
            },
            msram_256k4_ecc_aggr_regs: Msram256k4EccAggrRegs {
                _marker: PhantomData,
            },
            msram_256k3_ecc_aggr_regs: Msram256k3EccAggrRegs {
                _marker: PhantomData,
            },
            pru_icssg0_ecc_aggr: PruIcssg0EccAggr {
                _marker: PhantomData,
            },
            pru_icssg1_ecc_aggr: PruIcssg1EccAggr {
                _marker: PhantomData,
            },
            ecc_aggr0_ecc_aggr: EccAggr0EccAggr {
                _marker: PhantomData,
            },
            msram_256k6_ecc_aggr_regs: Msram256k6EccAggrRegs {
                _marker: PhantomData,
            },
            msram_256k7_ecc_aggr_regs: Msram256k7EccAggrRegs {
                _marker: PhantomData,
            },
            rom0: Rom0 {
                _marker: PhantomData,
            },
            ctrl_mmr0_cfg0: CtrlMmr0Cfg0 {
                _marker: PhantomData,
            },
            msram_256k7_ram0: Msram256k7Ram {
                _marker: PhantomData,
            },
            msram_256k7_ram1: Msram256k7Ram {
                _marker: PhantomData,
            },
            msram_256k6_ram0: Msram256k6Ram {
                _marker: PhantomData,
            },
            msram_256k6_ram1: Msram256k6Ram {
                _marker: PhantomData,
            },
            cbass0_fw: Cbass0Fw {
                _marker: PhantomData,
            },
            cbass_infra1_fw: CbassInfra1Fw {
                _marker: PhantomData,
            },
            cbass_infra1_isc: CbassInfra1Isc {
                _marker: PhantomData,
            },
            mcu_cbass0_isc: McuCbass0Isc {
                _marker: PhantomData,
            },
            dmass0_ringacc_0_ringacc_isc: Dmass0Ringacc0RingaccIsc {
                _marker: PhantomData,
            },
            cbass0_isc: Cbass0Isc {
                _marker: PhantomData,
            },
            cbass_infra1_glb: CbassInfra1Glb {
                _marker: PhantomData,
            },
            mcu_cbass0_glb: McuCbass0Glb {
                _marker: PhantomData,
            },
            cbass0_glb: Cbass0Glb {
                _marker: PhantomData,
            },
            cbass_infra1_qos: CbassInfra1Qos {
                _marker: PhantomData,
            },
            mcu_cbass0_qos: McuCbass0Qos {
                _marker: PhantomData,
            },
            cbass0_qos: Cbass0Qos {
                _marker: PhantomData,
            },
            dmass0_intaggr_0_intaggr_intr: Dmass0Intaggr0IntaggrIntr {
                _marker: PhantomData,
            },
            dmass0_intaggr_0_intaggr_imap: Dmass0Intaggr0IntaggrImap {
                _marker: PhantomData,
            },
            dmass0_intaggr_0_intaggr_cfg: Dmass0Intaggr0IntaggrCfg {
                _marker: PhantomData,
            },
            dmass0_intaggr_0_intaggr_l2g: Dmass0Intaggr0IntaggrL2g {
                _marker: PhantomData,
            },
            dmass0_psilcfg_0_psilcfg_proxy: Dmass0Psilcfg0PsilcfgProxy {
                _marker: PhantomData,
            },
            dmass0_psilss_0_psilss_mmrs: Dmass0Psilss0PsilssMmrs {
                _marker: PhantomData,
            },
            dmass0_intaggr_0_intaggr_unmap: Dmass0Intaggr0IntaggrUnmap {
                _marker: PhantomData,
            },
            dmass0_intaggr_0_intaggr_mcast: Dmass0Intaggr0IntaggrMcast {
                _marker: PhantomData,
            },
            dmass0_intaggr_0_intaggr_gcntcfg: Dmass0Intaggr0IntaggrGcntcfg {
                _marker: PhantomData,
            },
            dmass0_psilss_0_etlsw_mmrs: Dmass0Psilss0EtlswMmrs {
                _marker: PhantomData,
            },
            dmass0_ringacc_0_ringacc_gcfg: Dmass0Ringacc0RingaccGcfg {
                _marker: PhantomData,
            },
            dmass0_bcdma_0_bcdma_cred: Dmass0Bcdma0BcdmaCred {
                _marker: PhantomData,
            },
            dmass0_pktdma_0_pktdma_cred: Dmass0Pktdma0PktdmaCred {
                _marker: PhantomData,
            },
            dmass0_bcdma_0_bcdma_bchan: Dmass0Bcdma0BcdmaBchan {
                _marker: PhantomData,
            },
            dmass0_pktdma_0_pktdma_rflow: Dmass0Pktdma0PktdmaRflow {
                _marker: PhantomData,
            },
            dmass0_pktdma_0_pktdma_tchan: Dmass0Pktdma0PktdmaTchan {
                _marker: PhantomData,
            },
            dmass0_bcdma_0_bcdma_tchan: Dmass0Bcdma0BcdmaTchan {
                _marker: PhantomData,
            },
            dmass0_pktdma_0_pktdma_rchan: Dmass0Pktdma0PktdmaRchan {
                _marker: PhantomData,
            },
            dmass0_bcdma_0_bcdma_rchan: Dmass0Bcdma0BcdmaRchan {
                _marker: PhantomData,
            },
            dmass0_pktdma_0_pktdma_gcfg: Dmass0Pktdma0PktdmaGcfg {
                _marker: PhantomData,
            },
            dmass0_bcdma_0_bcdma_gcfg: Dmass0Bcdma0BcdmaGcfg {
                _marker: PhantomData,
            },
            dmass0_pktdma_0_pktdma_ring: Dmass0Pktdma0PktdmaRing {
                _marker: PhantomData,
            },
            dmass0_bcdma_0_bcdma_ring: Dmass0Bcdma0BcdmaRing {
                _marker: PhantomData,
            },
            dmass0_ringacc_0_ringacc_rt: Dmass0Ringacc0RingaccRt {
                _marker: PhantomData,
            },
            dmass0_ringacc_0_ringacc_cfg: Dmass0Ringacc0RingaccCfg {
                _marker: PhantomData,
            },
            dmass0_intaggr_0_intaggr_gcntrti: Dmass0Intaggr0IntaggrGcntrti {
                _marker: PhantomData,
            },
            dmass0_pktdma_0_pktdma_rchanrt: Dmass0Pktdma0PktdmaRchanrt {
                _marker: PhantomData,
            },
            dmass0_bcdma_0_bcdma_rchanrt: Dmass0Bcdma0BcdmaRchanrt {
                _marker: PhantomData,
            },
            dmass0_pktdma_0_pktdma_tchanrt: Dmass0Pktdma0PktdmaTchanrt {
                _marker: PhantomData,
            },
            dmass0_bcdma_0_bcdma_tchanrt: Dmass0Bcdma0BcdmaTchanrt {
                _marker: PhantomData,
            },
            dmass0_pktdma_0_pktdma_ringrt: Dmass0Pktdma0PktdmaRingrt {
                _marker: PhantomData,
            },
            dmass0_bcdma_0_bcdma_ringrt: Dmass0Bcdma0BcdmaRingrt {
                _marker: PhantomData,
            },
            dmass0_bcdma_0_bcdma_bchanrt: Dmass0Bcdma0BcdmaBchanrt {
                _marker: PhantomData,
            },
            dmass0_ringacc_0_ringacc_src_fifos: Dmass0Ringacc0RingaccSrcFifos {
                _marker: PhantomData,
            },
            fss0_fsas_0_dat_reg1: Fss0Fsas0DatReg1 {
                _marker: PhantomData,
            },
            msram_256k0_ram: Msram256k0Ram {
                _marker: PhantomData,
            },
            msram_256k1_ram: Msram256k1Ram {
                _marker: PhantomData,
            },
            msram_256k2_ram: Msram256k2Ram {
                _marker: PhantomData,
            },
            msram_256k3_ram: Msram256k3Ram {
                _marker: PhantomData,
            },
            msram_256k4_ram: Msram256k4Ram {
                _marker: PhantomData,
            },
            msram_256k5_ram: Msram256k5Ram {
                _marker: PhantomData,
            },
            msram_256k6_ram: Msram256k6Ram {
                _marker: PhantomData,
            },
            msram_256k7_ram: Msram256k7Ram {
                _marker: PhantomData,
            },
            fss0_fsas_0_dat_reg0: Fss0Fsas0DatReg0 {
                _marker: PhantomData,
            },
            fss0_fsas_0_dat_reg3: Fss0Fsas0DatReg3 {
                _marker: PhantomData,
            },
            a53ss0_ss_rom: A53ss0SsRom {
                _marker: PhantomData,
            },
            a53ss0_core0_dbg: A53ss0Core0Dbg {
                _marker: PhantomData,
            },
            a53ss0_core0_cti: A53ss0Core0Cti {
                _marker: PhantomData,
            },
            a53ss0_core0_pmu: A53ss0Core0Pmu {
                _marker: PhantomData,
            },
            a53ss0_core0_etm: A53ss0Core0Etm {
                _marker: PhantomData,
            },
            a53ss0_core1_dbg: A53ss0Core1Dbg {
                _marker: PhantomData,
            },
            a53ss0_core1_pmu: A53ss0Core1Pmu {
                _marker: PhantomData,
            },
            a53ss0_core1_etm: A53ss0Core1Etm {
                _marker: PhantomData,
            },
            a53ss0_core1_cti: A53ss0Core1Cti {
                _marker: PhantomData,
            },
            stm0_cxstm: Stm0Cxstm {
                _marker: PhantomData,
            },
            stm0_cti_cscti: Stm0CtiCscti {
                _marker: PhantomData,
            },
        }
    }
}
